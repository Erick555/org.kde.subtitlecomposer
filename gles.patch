diff --git a/.travis.yml b/.travis.yml
index ccabffe..938f3da 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -23,9 +23,9 @@ matrix:
         sudo apt-get update -qq
       install:
         - |- # dependencies
-         sudo apt-get install -yqq curl cmake make extra-cmake-modules kross-dev libavformat-dev libswscale-dev libopenal-dev breeze \
-                                  qtbase5-dev qtbase5-private-dev libkf5auth-dev libkf5codecs-dev libkf5config-dev libkf5configwidgets-dev \
-                                  libkf5coreaddons-dev libkf5i18n-dev libkf5kio-dev kross-dev libkf5sonnet-dev libkf5textwidgets-dev \
+         sudo apt-get install -yqq curl cmake make extra-cmake-modules libavformat-dev libswscale-dev libopenal-dev breeze qtbase5-dev \
+                                  qtbase5-private-dev qtdeclarative5-dev libkf5auth-dev libkf5codecs-dev libkf5config-dev libkf5configwidgets-dev \
+                                  libkf5coreaddons-dev libkf5i18n-dev libkf5kio-dev libkf5sonnet-dev libkf5textwidgets-dev \
                                   libkf5widgetsaddons-dev libkf5xmlgui-dev libicu-dev libsphinxbase-dev libpocketsphinx-dev
       script:
         - |-
@@ -50,9 +50,9 @@ matrix:
         sudo apt-get update -qq
       install:
         - |- # dependencies
-         sudo apt-get install -yqq curl cmake make extra-cmake-modules kross-dev libavformat-dev libswscale-dev libopenal-dev breeze \
-                                  qtbase5-dev qtbase5-private-dev libkf5auth-dev libkf5codecs-dev libkf5config-dev libkf5configwidgets-dev \
-                                  libkf5coreaddons-dev libkf5i18n-dev libkf5kio-dev kross-dev libkf5sonnet-dev libkf5textwidgets-dev \
+         sudo apt-get install -yqq curl cmake make extra-cmake-modules libavformat-dev libswscale-dev libopenal-dev breeze qtbase5-dev \
+                                  qtbase5-private-dev qtdeclarative5-dev libkf5auth-dev libkf5codecs-dev libkf5config-dev libkf5configwidgets-dev \
+                                  libkf5coreaddons-dev libkf5i18n-dev libkf5kio-dev libkf5sonnet-dev libkf5textwidgets-dev \
                                   libkf5widgetsaddons-dev libkf5xmlgui-dev libicu-dev libsphinxbase-dev libpocketsphinx-dev
       script:
         - |-
@@ -81,9 +81,9 @@ matrix:
         sudo apt-get update -qq
       install:
         - |- # dependencies
-         sudo apt-get install -yq curl cmake make extra-cmake-modules kross-dev libavformat-dev libswscale-dev libopenal-dev breeze \
-                                  qtbase5-dev qtbase5-private-dev libkf5auth-dev libkf5codecs-dev libkf5config-dev libkf5configwidgets-dev \
-                                  libkf5coreaddons-dev libkf5i18n-dev libkf5kio-dev kross-dev libkf5sonnet-dev libkf5textwidgets-dev \
+         sudo apt-get install -yqq curl cmake make extra-cmake-modules libavformat-dev libswscale-dev libopenal-dev breeze qtbase5-dev \
+                                  qtbase5-private-dev qtdeclarative5-dev libkf5auth-dev libkf5codecs-dev libkf5config-dev libkf5configwidgets-dev \
+                                  libkf5coreaddons-dev libkf5i18n-dev libkf5kio-dev libkf5sonnet-dev libkf5textwidgets-dev \
                                   libkf5widgetsaddons-dev libkf5xmlgui-dev libicu-dev libsphinxbase-dev libpocketsphinx-dev
       script:
         - |-
@@ -112,9 +112,9 @@ matrix:
         sudo apt-get update -qq
       install:
         - |- # dependencies
-         sudo apt-get install -yq curl cmake make extra-cmake-modules kross-dev libavformat-dev libswscale-dev libopenal-dev breeze \
-                                  qtbase5-dev qtbase5-private-dev libkf5auth-dev libkf5codecs-dev libkf5config-dev libkf5configwidgets-dev \
-                                  libkf5coreaddons-dev libkf5i18n-dev libkf5kio-dev kross-dev libkf5sonnet-dev libkf5textwidgets-dev \
+         sudo apt-get install -yqq curl cmake make extra-cmake-modules libavformat-dev libswscale-dev libopenal-dev breeze qtbase5-dev \
+                                  qtbase5-private-dev qtdeclarative5-dev libkf5auth-dev libkf5codecs-dev libkf5config-dev libkf5configwidgets-dev \
+                                  libkf5coreaddons-dev libkf5i18n-dev libkf5kio-dev libkf5sonnet-dev libkf5textwidgets-dev \
                                   libkf5widgetsaddons-dev libkf5xmlgui-dev libicu-dev libsphinxbase-dev libpocketsphinx-dev
       script:
         - |-
diff --git a/CMakeLists.txt b/CMakeLists.txt
index b9399d2..062c069 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,7 +1,7 @@
 cmake_policy(SET CMP0048 NEW)
 project(subtitlecomposer VERSION "0.7.1")
 
-cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.4...3.20 FATAL_ERROR)
 set(QT_MIN_VERSION "5.9.0")
 set(KF5_MIN_VERSION "5.44.0")
 
@@ -9,13 +9,7 @@ set(CMAKE_CXX_STANDARD 11)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 
 find_package(ECM 1.2.0 REQUIRED NO_MODULE)
-set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${ECM_MODULE_PATH} ${ECM_KDE_MODULE_DIR} "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
-
-cmake_policy(SET CMP0043 NEW)
-cmake_policy(SET CMP0063 NEW)
-if(POLICY CMP0071)
-	cmake_policy(SET CMP0071 NEW)
-endif()
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${ECM_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
 include(KDEInstallDirs)
 include(KDECMakeSettings)
@@ -28,11 +22,11 @@ include(ECMAddTests) # build tests
 include(FeatureSummary)
 
 find_package(Qt5 ${QT_MIN_VERSION} CONFIG REQUIRED COMPONENTS
-	Core Widgets Gui Test)
+	Core Widgets Gui Test Qml)
 
 find_package(KF5 ${KF5_MIN_VERSION} REQUIRED COMPONENTS
 	Auth Config ConfigWidgets CoreAddons I18n KIO XmlGui
-	Sonnet Kross Codecs TextWidgets WidgetsAddons)
+	Sonnet Codecs TextWidgets WidgetsAddons)
 
 #PO_SUBDIR
 add_subdirectory(src)
diff --git a/README.md b/README.md
index 14f20c8..859cf28 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 ## Subtitle Composer
 [![Linux Build](https://subtitlecomposer.smoothware.net/badge.php?p=job/kf5-qt5&os=suse&t=Linux+Build)](https://build.kde.org/job/Extragear/job/subtitlecomposer/)
 [![FreeBSD Build](https://subtitlecomposer.smoothware.net/badge.php?p=job/kf5-qt5&os=bsd&t=FreeBSD+Build)](https://build.kde.org/job/Extragear/job/subtitlecomposer/)
-[![TravisCI Build](https://img.shields.io/travis/com/maxrd2/subtitlecomposer/master.svg?label=Travis+Builds)](https://travis-ci.com/maxrd2/subtitlecomposer)
+[![TravisCI Build](https://img.shields.io/travis/com/maxrd2/subtitlecomposer/master.svg?label=Travis+Builds)](https://app.travis-ci.com/github/maxrd2/SubtitleComposer)
 [![Localization](https://d322cqt584bo4o.cloudfront.net/subtitlecomposer/localized.svg)](https://l10n.kde.org/stats/gui/trunk-kf5/po/subtitlecomposer.po/)
 
 An open source text-based subtitle editor that supports basic and advanced editing operations, aiming to become an improved version of Subtitle Workshop for every platform supported by Plasma Frameworks.
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 1cb7098..1ecbf0a 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -100,11 +100,11 @@ qt5_add_resources(subtitlecomposer_RES_SRC ${subtitlecomposer_RES})
 
 add_library(subtitlecomposer-lib STATIC ${subtitlecomposer_SRCS})
 target_link_libraries(subtitlecomposer-lib
-	Qt5::Core Qt5::Widgets Qt5::WidgetsPrivate Qt5::Gui
+	Qt5::Core Qt5::Widgets Qt5::WidgetsPrivate Qt5::Gui Qt5::Qml
 	KF5::CoreAddons KF5::WidgetsAddons KF5::TextWidgets KF5::Codecs
 	KF5::SonnetCore KF5::SonnetUi
 	KF5::KIOCore KF5::KIOFileWidgets KF5::KIOWidgets KF5::KIONTLM
-	KF5::KrossCore KF5::KrossUi KF5::XmlGui KF5::I18n
+	KF5::XmlGui KF5::I18n
 	${FFMPEG_LIBRARIES}
 	${OPENAL_LIBRARY}
 	${ICU_LIBRARIES}
diff --git a/src/application.cpp b/src/application.cpp
index 7478e73..e8fb7b9 100644
--- a/src/application.cpp
+++ b/src/application.cpp
@@ -165,7 +165,7 @@ Application::init()
 
 #define CONNECT_SUB(c, x) \
 	connect(this, &Application::subtitleOpened, x, &c::setSubtitle); \
-	connect(this, &Application::subtitleClosed, x, [this](){ x->setSubtitle(nullptr); });
+	connect(this, &Application::subtitleClosed, x, [&](){ x->setSubtitle(nullptr); });
 
 	CONNECT_SUB(UserActionManager, UserActionManager::instance());
 	CONNECT_SUB(MainWindow, m_mainWindow);
diff --git a/src/application_subtitle.cpp b/src/application_subtitle.cpp
index 6471488..a1d29fd 100644
--- a/src/application_subtitle.cpp
+++ b/src/application_subtitle.cpp
@@ -154,7 +154,7 @@ Application::openSubtitle()
 	openDlg.selectUrl(m_lastSubtitleUrl);
 
 	if(openDlg.exec() == QDialog::Accepted)
-		openSubtitle(openDlg.selectedUrls().first());
+		openSubtitle(openDlg.selectedUrls().constFirst());
 }
 
 void
@@ -393,10 +393,10 @@ Application::closeSubtitle()
 			emit translationModeChanged(false);
 		}
 
-		m_undoStack->clear();
-
 		emit subtitleClosed();
 
+		m_undoStack->clear();
+
 		m_subtitle.reset();
 
 		m_labSubFormat->setText(QString());
@@ -459,10 +459,10 @@ Application::openSubtitleTr(const QUrl &url, bool warnClashingUrls)
 	if(!closeSubtitleTr())
 		return;
 
-	Subtitle subtitleTr;
+	QExplicitlySharedDataPointer<Subtitle> subtitleTr(new Subtitle());
 	QTextCodec *codec = codecForEncoding(KRecentFilesActionExt::encodingForUrl(url));
 
-	FormatManager::Status res = FormatManager::instance().readSubtitle(subtitleTr, false, url, &codec, &m_subtitleTrFormat);
+	FormatManager::Status res = FormatManager::instance().readSubtitle(*subtitleTr, false, url, &codec, &m_subtitleTrFormat);
 	if(res != FormatManager::SUCCESS) {
 		if(res == FormatManager::ERROR) {
 			KMessageBox::sorry(
@@ -474,7 +474,7 @@ Application::openSubtitleTr(const QUrl &url, bool warnClashingUrls)
 	}
 
 	m_subtitleTrUrl = url;
-	m_subtitle->setSecondaryData(subtitleTr, false);
+	m_subtitle->setSecondaryData(*subtitleTr, false);
 	processTranslationOpened(codec, m_subtitleTrFormat);
 }
 
@@ -484,10 +484,10 @@ Application::reopenSubtitleTrWithCodec(QTextCodec *codec)
 	if(m_subtitleTrUrl.isEmpty())
 		return;
 
-	Subtitle subtitleTr;
+	QExplicitlySharedDataPointer<Subtitle> subtitleTr(new Subtitle());
 	QString subtitleTrFormat;
 
-	FormatManager::Status res = FormatManager::instance().readSubtitle(subtitleTr, false, m_subtitleTrUrl, &codec, &subtitleTrFormat);
+	FormatManager::Status res = FormatManager::instance().readSubtitle(*subtitleTr, false, m_subtitleTrUrl, &codec, &subtitleTrFormat);
 	if(res != FormatManager::SUCCESS) {
 		if(res == FormatManager::ERROR) {
 			KMessageBox::sorry(
@@ -498,7 +498,7 @@ Application::reopenSubtitleTrWithCodec(QTextCodec *codec)
 		return;
 	}
 
-	m_subtitle->setSecondaryData(subtitleTr, false);
+	m_subtitle->setSecondaryData(*subtitleTr, false);
 	processTranslationOpened(codec, m_subtitleTrFormat);
 }
 
@@ -686,18 +686,18 @@ Application::joinSubtitles()
 	static JoinSubtitlesDialog *dlg = new JoinSubtitlesDialog(m_mainWindow);
 
 	if(dlg->exec() == QDialog::Accepted) {
-		Subtitle secondSubtitle;
+		QExplicitlySharedDataPointer<Subtitle> secondSubtitle(new Subtitle());
 
 		const QUrl url = dlg->subtitleUrl();
 		QTextCodec *codec = codecForEncoding(KRecentFilesActionExt::encodingForUrl(url));
 		const bool primary = dlg->selectedTextsTarget() != Secondary;
 
-		FormatManager::Status res = FormatManager::instance().readSubtitle(secondSubtitle, primary, url, &codec, nullptr);
+		FormatManager::Status res = FormatManager::instance().readSubtitle(*secondSubtitle, primary, url, &codec, nullptr);
 		if(res == FormatManager::SUCCESS) {
 			if(dlg->selectedTextsTarget() == Both)
-				secondSubtitle.setSecondaryData(secondSubtitle, true);
+				secondSubtitle->setSecondaryData(*secondSubtitle, true);
 
-			m_subtitle->appendSubtitle(secondSubtitle, dlg->shiftTime().toMillis());
+			m_subtitle->appendSubtitle(*secondSubtitle, dlg->shiftTime().toMillis());
 		} else {
 			KMessageBox::sorry(m_mainWindow, i18n("Could not read the subtitle file to append."));
 		}
@@ -712,15 +712,15 @@ Application::splitSubtitle()
 	if(dlg->exec() != QDialog::Accepted)
 		return;
 
-	Subtitle newSubtitle;
-	m_subtitle->splitSubtitle(newSubtitle, dlg->splitTime().toMillis(), dlg->shiftNewSubtitle());
-	if(!newSubtitle.linesCount()) {
+	QExplicitlySharedDataPointer<Subtitle> newSubtitle(new Subtitle());
+	m_subtitle->splitSubtitle(*newSubtitle, dlg->splitTime().toMillis(), dlg->shiftNewSubtitle());
+	if(!newSubtitle->linesCount()) {
 		KMessageBox::information(m_mainWindow, i18n("The specified time does not split the subtitles."));
 		return;
 	}
 
 	QUrl splitUrl = saveSplitSubtitle(
-		newSubtitle,
+		*newSubtitle,
 		m_subtitleUrl,
 		m_subtitleEncoding,
 		m_subtitleFormat,
@@ -734,7 +734,7 @@ Application::splitSubtitle()
 
 	QUrl splitTrUrl;
 	if(m_translationMode) {
-		splitTrUrl = saveSplitSubtitle(newSubtitle, m_subtitleTrUrl, m_subtitleTrEncoding, m_subtitleTrFormat, false);
+		splitTrUrl = saveSplitSubtitle(*newSubtitle, m_subtitleTrUrl, m_subtitleTrEncoding, m_subtitleTrFormat, false);
 
 		if(splitTrUrl.path().isEmpty()) {
 			// there was an error saving the split part, undo the splitting of m_subtitle
@@ -761,21 +761,21 @@ Application::syncWithSubtitle()
 	static SyncSubtitlesDialog *dlg = new SyncSubtitlesDialog(m_mainWindow);
 
 	if(dlg->exec() == QDialog::Accepted) {
-		Subtitle referenceSubtitle;
+		QExplicitlySharedDataPointer<Subtitle> referenceSubtitle(new Subtitle());
 
 		const QUrl url = dlg->subtitleUrl();
 
-		FormatManager::Status res = FormatManager::instance().readSubtitle(referenceSubtitle, true, url, nullptr, nullptr);
+		FormatManager::Status res = FormatManager::instance().readSubtitle(*referenceSubtitle, true, url, nullptr, nullptr);
 		if(res == FormatManager::SUCCESS) {
 			if(dlg->adjustToReferenceSubtitle()) {
-				if(referenceSubtitle.linesCount() <= 1)
+				if(referenceSubtitle->linesCount() <= 1)
 					KMessageBox::sorry(m_mainWindow, i18n("The reference subtitle must have more than one line to proceed."));
 				else
 					m_subtitle->adjustLines(Range::full(),
-											referenceSubtitle.firstLine()->showTime().toMillis(),
-											referenceSubtitle.lastLine()->showTime().toMillis());
+											referenceSubtitle->firstLine()->showTime().toMillis(),
+											referenceSubtitle->lastLine()->showTime().toMillis());
 			} else /*if(dlg->synchronizeToReferenceTimes())*/ {
-				m_subtitle->syncWithSubtitle(referenceSubtitle);
+				m_subtitle->syncWithSubtitle(*referenceSubtitle);
 			}
 		} else {
 			KMessageBox::sorry(m_mainWindow, i18n("Could not parse the reference subtitle file."));
diff --git a/src/configs/errorsconfigwidget.cpp b/src/configs/errorsconfigwidget.cpp
index d09f306..c56c924 100644
--- a/src/configs/errorsconfigwidget.cpp
+++ b/src/configs/errorsconfigwidget.cpp
@@ -17,20 +17,20 @@ ErrorsConfigWidget::ErrorsConfigWidget(QWidget *parent)
 {
 	setupUi(this);
 
-	connect(kcfg_MinDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), [this](int val){
+	connect(kcfg_MinDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), this, [this](int val){
 		QSignalBlocker b(alt_MinDurationPerCharacter);
 		alt_MinDurationPerCharacter->setValue(1000 / val);
 		kcfg_IdealDurationPerCharacter->setMinimum(val);
 		alt_IdealDurationPerCharacter->setMaximum(1000 / val);
 	});
-	connect(alt_MinDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), [this](int val){
+	connect(alt_MinDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), this, [this](int val){
 		QSignalBlocker b(kcfg_MinDurationPerCharacter);
 		kcfg_MinDurationPerCharacter->setValue(1000 / val);
 		alt_IdealDurationPerCharacter->setMaximum(val);
 		kcfg_IdealDurationPerCharacter->setMinimum(1000 / val);
 	});
 
-	connect(kcfg_IdealDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), [this](int val){
+	connect(kcfg_IdealDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), this, [this](int val){
 		QSignalBlocker b(alt_IdealDurationPerCharacter);
 		alt_IdealDurationPerCharacter->setValue(1000 / val);
 		kcfg_MinDurationPerCharacter->setMaximum(val);
@@ -38,7 +38,7 @@ ErrorsConfigWidget::ErrorsConfigWidget(QWidget *parent)
 		alt_MinDurationPerCharacter->setMinimum(1000 / val);
 		alt_MaxDurationPerCharacter->setMaximum(1000 / val);
 	});
-	connect(alt_IdealDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), [this](int val){
+	connect(alt_IdealDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), this, [this](int val){
 		QSignalBlocker b(kcfg_IdealDurationPerCharacter);
 		kcfg_IdealDurationPerCharacter->setValue(1000 / val);
 		alt_MinDurationPerCharacter->setMinimum(val);
@@ -47,13 +47,13 @@ ErrorsConfigWidget::ErrorsConfigWidget(QWidget *parent)
 		kcfg_MaxDurationPerCharacter->setMinimum(1000 / val);
 	});
 
-	connect(kcfg_MaxDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), [this](int val){
+	connect(kcfg_MaxDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), this, [this](int val){
 		QSignalBlocker b(alt_MaxDurationPerCharacter);
 		alt_MaxDurationPerCharacter->setValue(1000 / val);
 		kcfg_IdealDurationPerCharacter->setMaximum(val);
 		alt_IdealDurationPerCharacter->setMinimum(1000 / val);
 	});
-	connect(alt_MaxDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), [this](int val){
+	connect(alt_MaxDurationPerCharacter, QOverload<int>::of(&QSpinBox::valueChanged), this, [this](int val){
 		QSignalBlocker b(kcfg_MaxDurationPerCharacter);
 		kcfg_MaxDurationPerCharacter->setValue(1000 / val);
 		alt_IdealDurationPerCharacter->setMinimum(val);
diff --git a/src/core/richdocumenteditor.cpp b/src/core/richdocumenteditor.cpp
index 3f59948..6837f93 100644
--- a/src/core/richdocumenteditor.cpp
+++ b/src/core/richdocumenteditor.cpp
@@ -498,7 +498,7 @@ RichDocumentEditor::finishChange(bool edited)
 		emit selectionChanged();
 	}
 	if(m_textCursor->position() == m_lastCursorPos)
-		updateMicroFocus();
+		emit updateMicroFocus();
 	emitCursorPositionChanged();
 	return true;
 }
@@ -645,7 +645,7 @@ RichDocumentEditor::emitCursorPositionChanged()
 	if(curPos != m_lastCursorPos) {
 		const int oldLast = m_lastCursorPos;
 		m_lastCursorPos = curPos;
-		cursorPositionChanged(oldLast, curPos);
+		emit cursorPositionChanged(oldLast, curPos);
 #ifndef QT_NO_ACCESSIBILITY
 		// otherwise we send a selection update which includes the cursor
 		if(!hasSelection()) {
diff --git a/src/core/sstring.cpp b/src/core/sstring.cpp
index c062c15..d1e8dc4 100644
--- a/src/core/sstring.cpp
+++ b/src/core/sstring.cpp
@@ -188,7 +188,7 @@ SString::richString(RichOutputMode mode) const
 				if(currentStyleFlags & Color)
 					ret += "<font color=" + QColor(currentColor).name() + ">";
 
-				ret += QString::mid(prevIndex, index - prevIndex);
+				ret += QString::midRef(prevIndex, index - prevIndex);
 
 				if(currentStyleFlags & Color)
 					ret += "</font>";
@@ -220,7 +220,7 @@ SString::richString(RichOutputMode mode) const
 			if(currentStyleFlags & Color)
 				ret += "<font color=" + QColor(currentColor).name() + ">";
 
-			ret += QString::mid(prevIndex);
+			ret += QString::midRef(prevIndex);
 
 			if(currentStyleFlags & Color)
 				ret += "</font>";
diff --git a/src/core/subtitle.cpp b/src/core/subtitle.cpp
index 7d9659a..709fa00 100644
--- a/src/core/subtitle.cpp
+++ b/src/core/subtitle.cpp
@@ -1368,10 +1368,12 @@ Subtitle::recheckErrors(const RangeList &ranges)
 void
 Subtitle::processAction(UndoAction *action) const
 {
-	if(app()->subtitle() == this)
+	if(app()->subtitle() == this) {
 		app()->undoStack()->push(action);
-	else
+	} else {
 		action->redo();
+		delete action;
+	}
 }
 
 void
diff --git a/src/core/undo/undostack.cpp b/src/core/undo/undostack.cpp
index d9603fe..ce3064d 100644
--- a/src/core/undo/undostack.cpp
+++ b/src/core/undo/undostack.cpp
@@ -114,8 +114,8 @@ UndoStack::push(UndoAction *cmd)
 	const int idx = index();
 	const int idx1 = idx + 1;
 	levelIncrease(idx1);
-	QUndoStack::push(cmd);
 	m_dirtyStack[idx] = static_cast<DirtyMode>(m_dirtyStack.at(idx) | cmd->m_dirtyMode);
+	QUndoStack::push(cmd); // NOTE: cmd can/will be deleted after push()
 	levelDecrease(idx1);
 }
 
diff --git a/src/dialogs/encodingdetectdialog.cpp b/src/dialogs/encodingdetectdialog.cpp
index 4517214..4fee611 100644
--- a/src/dialogs/encodingdetectdialog.cpp
+++ b/src/dialogs/encodingdetectdialog.cpp
@@ -50,7 +50,7 @@ EncodingDetectDialog::EncodingDetectDialog(const QByteArray &text, QWidget *pare
 	ui->encoding->setModel(model);
 
 	ui->buttonBox->button(QDialogButtonBox::Ok)->setDisabled(true);
-	connect(ui->encoding->selectionModel(), &QItemSelectionModel::selectionChanged, [&, model](const QItemSelection &sel, const QItemSelection &){
+	connect(ui->encoding->selectionModel(), &QItemSelectionModel::selectionChanged, this, [&, model](const QItemSelection &sel, const QItemSelection &){
 		const bool hasSelection = !sel.isEmpty() && !sel.first().isEmpty();
 		ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(hasSelection);
 
diff --git a/src/formats/formatmanager.cpp b/src/formats/formatmanager.cpp
index 551c1d3..2c7479f 100644
--- a/src/formats/formatmanager.cpp
+++ b/src/formats/formatmanager.cpp
@@ -154,8 +154,8 @@ FormatManager::readBinary(Subtitle &subtitle, const QUrl &url, bool primary,
 						  QTextCodec **codec, QString *formatName) const
 {
 	foreach(InputFormat *format, m_inputFormats) {
-		Subtitle newSubtitle;
-		Status res = format->readBinary(newSubtitle, url);
+		QExplicitlySharedDataPointer<Subtitle> newSubtitle(new Subtitle());
+		Status res = format->readBinary(*newSubtitle, url);
 		if(res == ERROR)
 			continue;
 		if(res == SUCCESS) {
@@ -163,9 +163,9 @@ FormatManager::readBinary(Subtitle &subtitle, const QUrl &url, bool primary,
 				*formatName = format->name();
 			*codec = KCharsets::charsets()->codecForName(SCConfig::defaultSubtitlesEncoding());
 			if(primary)
-				subtitle.setPrimaryData(newSubtitle, true);
+				subtitle.setPrimaryData(*newSubtitle, true);
 			else
-				subtitle.setSecondaryData(newSubtitle, true);
+				subtitle.setSecondaryData(*newSubtitle, true);
 		}
 		return res;
 	}
diff --git a/src/formats/inputformat.h b/src/formats/inputformat.h
index d7a290e..99d945f 100644
--- a/src/formats/inputformat.h
+++ b/src/formats/inputformat.h
@@ -17,15 +17,15 @@ class InputFormat : public Format
 public:
 	bool readSubtitle(Subtitle &subtitle, bool primary, const QString &data) const
 	{
-		Subtitle newSubtitle;
+		QExplicitlySharedDataPointer<Subtitle> newSubtitle(new Subtitle());
 
-		if(!parseSubtitles(newSubtitle, data))
+		if(!parseSubtitles(*newSubtitle, data))
 			return false;
 
 		if(primary)
-			subtitle.setPrimaryData(newSubtitle, true);
+			subtitle.setPrimaryData(*newSubtitle, true);
 		else
-			subtitle.setSecondaryData(newSubtitle, true);
+			subtitle.setSecondaryData(*newSubtitle, true);
 
 		return true;
 	}
diff --git a/src/formats/substationalpha/substationalphaoutputformat.h b/src/formats/substationalpha/substationalphaoutputformat.h
index 43fd95b..b128962 100644
--- a/src/formats/substationalpha/substationalphaoutputformat.h
+++ b/src/formats/substationalpha/substationalphaoutputformat.h
@@ -44,9 +44,9 @@ public:
 			if(prevColor != curColor) {
 				subtitle += QStringLiteral("{\\c&H");
 				if(curColor != 0) {
-					subtitle += (QChar('0') + QString::number(qBlue(curColor), 16)).toUpper().right(2);
-					subtitle += (QChar('0') + QString::number(qGreen(curColor), 16)).toUpper().right(2);
-					subtitle += (QChar('0') + QString::number(qRed(curColor), 16)).toUpper().right(2);
+					subtitle += (QChar('0') + QString::number(qBlue(curColor), 16)).toUpper().rightRef(2);
+					subtitle += (QChar('0') + QString::number(qGreen(curColor), 16)).toUpper().rightRef(2);
+					subtitle += (QChar('0') + QString::number(qRed(curColor), 16)).toUpper().rightRef(2);
 				} else {
 					subtitle += QStringLiteral("00");
 				}
diff --git a/src/formats/vobsub/vobsubinputprocessdialog.cpp b/src/formats/vobsub/vobsubinputprocessdialog.cpp
index daca7b7..29ec2e7 100644
--- a/src/formats/vobsub/vobsubinputprocessdialog.cpp
+++ b/src/formats/vobsub/vobsubinputprocessdialog.cpp
@@ -367,17 +367,17 @@ VobSubInputProcessDialog::VobSubInputProcessDialog(Subtitle *subtitle, QWidget *
 	connect(ui->btnOk, &QPushButton::clicked, this, &VobSubInputProcessDialog::onOkClicked);
 	connect(ui->btnAbort, &QPushButton::clicked, this, &VobSubInputProcessDialog::onAbortClicked);
 
-	connect(ui->styleBold, &QPushButton::toggled, [this](bool checked){
+	connect(ui->styleBold, &QPushButton::toggled, this, [this](bool checked){
 		QFont font = ui->lineEdit->font();
 		font.setBold(checked);
 		ui->lineEdit->setFont(font);
 	});
-	connect(ui->styleItalic, &QPushButton::toggled, [this](bool checked){
+	connect(ui->styleItalic, &QPushButton::toggled, this, [this](bool checked){
 		QFont font = ui->lineEdit->font();
 		font.setItalic(checked);
 		ui->lineEdit->setFont(font);
 	});
-	connect(ui->styleUnderline, &QPushButton::toggled, [this](bool checked){
+	connect(ui->styleUnderline, &QPushButton::toggled, this, [this](bool checked){
 		QFont font = ui->lineEdit->font();
 		font.setUnderline(checked);
 		ui->lineEdit->setFont(font);
diff --git a/src/gui/currentlinewidget.cpp b/src/gui/currentlinewidget.cpp
index 5fad133..db6ecd7 100644
--- a/src/gui/currentlinewidget.cpp
+++ b/src/gui/currentlinewidget.cpp
@@ -158,7 +158,7 @@ CurrentLineWidget::createLineWidgetBox(int index)
 	connect(btnColor, &QToolButton::clicked, textEdit, &SimpleRichTextEdit::changeTextColor);
 	layout->addWidget(btnColor, 0, 6, Qt::AlignBottom);
 
-	connect(textEdit, &SimpleRichTextEdit::cursorPositionChanged, [=](){
+	connect(textEdit, &SimpleRichTextEdit::cursorPositionChanged, this, [=](){
 		btnBold->setChecked(textEdit->fontBold());
 		btnItalic->setChecked(textEdit->fontItalic());
 		btnUnderline->setChecked(textEdit->fontUnderline());
@@ -236,9 +236,6 @@ CurrentLineWidget::setCurrentLine(SubtitleLine *line)
 		connect(m_currentLine, &SubtitleLine::showTimeChanged, this, &CurrentLineWidget::onLineShowTimeChanged);
 		connect(m_currentLine, &SubtitleLine::hideTimeChanged, this, &CurrentLineWidget::onLineHideTimeChanged);
 
-		onLineShowTimeChanged(m_currentLine->showTime());
-		onLineHideTimeChanged(m_currentLine->hideTime());
-
 		RichDocument *doc = m_currentLine->primaryDoc();
 		if(m_textEdits[0]->isReadOnly())
 			m_textEdits[0]->setReadOnly(false);
@@ -253,7 +250,7 @@ CurrentLineWidget::setCurrentLine(SubtitleLine *line)
 		m_textEdits[1]->setDocument(doc);
 		connect(m_currentLine, &SubtitleLine::secondaryTextChanged, this, &CurrentLineWidget::updateLabels);
 
-		updateLabels();
+		onLineTimesChanged(m_currentLine->showTime(), m_currentLine->hideTime());
 
 		if(m_subtitle)
 			onLineAnchorChanged(m_currentLine, m_subtitle->isLineAnchored(m_currentLine));
@@ -267,8 +264,7 @@ CurrentLineWidget::setCurrentLine(SubtitleLine *line)
 		m_textLabels[1]->setText(i18n("No current line"));
 		m_textEdits[1]->setDocument(&m_blankDoc);
 		m_textEdits[1]->setReadOnly(true);
-		onLineShowTimeChanged(Time());
-		onLineHideTimeChanged(Time());
+		onLineTimesChanged(Time(), Time());
 
 		setEnabled(false);
 	}
@@ -359,12 +355,24 @@ CurrentLineWidget::onLineAnchorChanged(const SubtitleLine *line, bool anchored)
 		m_showTimeEdit->setEnabled(!m_subtitle->hasAnchors() || anchored);
 }
 
+void
+CurrentLineWidget::onLineTimesChanged(const Time &showTime, const Time &hideTime)
+{
+	QSignalBlocker s1(m_showTimeEdit), s2(m_hideTimeEdit), s3(m_durationTimeEdit);
+	const int showMillis = showTime.toMillis();
+	m_showTimeEdit->setValue(showMillis);
+	m_hideTimeEdit->setMinimumTime(QTime::fromMSecsSinceStartOfDay(showMillis));
+	m_hideTimeEdit->setValue(hideTime.toMillis());
+	m_durationTimeEdit->setValue(m_hideTimeEdit->value() - m_showTimeEdit->value());
+	updateLabels();
+}
+
 void
 CurrentLineWidget::onLineShowTimeChanged(const Time &showTime)
 {
 	QSignalBlocker s1(m_showTimeEdit), s2(m_hideTimeEdit), s3(m_durationTimeEdit);
 	m_showTimeEdit->setValue(showTime.toMillis());
-	m_hideTimeEdit->setMinimumTime(QTime(0, 0, 0, 0).addMSecs(showTime.toMillis()));
+	m_hideTimeEdit->setMinimumTime(QTime::fromMSecsSinceStartOfDay(showTime.toMillis()));
 	updateLabels();
 }
 
diff --git a/src/gui/currentlinewidget.h b/src/gui/currentlinewidget.h
index 5a0b0e5..c45de50 100644
--- a/src/gui/currentlinewidget.h
+++ b/src/gui/currentlinewidget.h
@@ -52,6 +52,7 @@ protected slots:
 
 	void onLineAnchorChanged(const SubtitleLine *line, bool anchored);
 
+	void onLineTimesChanged(const Time &showTime, const Time &hideTime);
 	void onLineShowTimeChanged(const Time &showTime);
 	void onLineHideTimeChanged(const Time &hideTime);
 
diff --git a/src/gui/playerwidget.cpp b/src/gui/playerwidget.cpp
index 3873403..38ec54d 100644
--- a/src/gui/playerwidget.cpp
+++ b/src/gui/playerwidget.cpp
@@ -238,7 +238,7 @@ PlayerWidget::PlayerWidget(QWidget *parent) :
 
 	setFullScreenMode(m_fullScreenMode);
 
-	connect(app(), &Application::actionsReady, [this](){
+	connect(app(), &Application::actionsReady, this, [this](){
 		toolButton(this, ACT_STOP)->setDefaultAction(app()->action(ACT_STOP));
 		toolButton(this, ACT_PLAY_PAUSE)->setDefaultAction(app()->action(ACT_PLAY_PAUSE));
 		toolButton(this, ACT_SEEK_BACKWARD)->setDefaultAction(app()->action(ACT_SEEK_BACKWARD));
diff --git a/src/gui/treeview/linesmodel.cpp b/src/gui/treeview/linesmodel.cpp
index e36c2dd..3a87113 100644
--- a/src/gui/treeview/linesmodel.cpp
+++ b/src/gui/treeview/linesmodel.cpp
@@ -292,7 +292,11 @@ LinesModel::onLinesInserted(int firstIndex, int lastIndex)
 	m_resetModelSelection.second = m_subtitle->at(lastIndex);
 	LinesWidget *lw = static_cast<LinesWidget *>(parent());
 	m_resetModelResumeEditing = lw->isEditing();
-	lw->selectionModel()->clear();
+	{
+		QItemSelectionModel *sm = lw->selectionModel();
+		QSignalBlocker s(sm);
+		sm->clear();
+	}
 	m_resetModelTimer->start();
 }
 
@@ -314,12 +318,14 @@ LinesModel::onLinesRemoved(int firstIndex, int lastIndex)
 void
 LinesModel::onModelReset()
 {
-	beginResetModel();
-	endResetModel();
-
 	LinesWidget *w = static_cast<LinesWidget *>(parent());
 	QItemSelectionModel *sm = w->selectionModel();
 
+	const QModelIndex prevIndex = sm->currentIndex();;
+
+	beginResetModel();
+	endResetModel();
+
 	if(sm->hasSelection()) {
 		if(!sm->currentIndex().isValid()) {
 			const QModelIndex idx = index(sm->selection().first().top());
@@ -332,6 +338,13 @@ LinesModel::onModelReset()
 			sm->select(QItemSelection(first, last), QItemSelectionModel::ClearAndSelect);
 		}
 		sm->setCurrentIndex(first, QItemSelectionModel::Rows);
+	} else {
+		if(prevIndex.isValid() && !sm->currentIndex().isValid()) {
+			// model reset should invalidate current index and prevent signals
+			QSignalBlocker s(sm); // make sure nothing fires anyway
+			sm->setCurrentIndex(prevIndex, QItemSelectionModel::Rows);
+		}
+		sm->clear();
 	}
 
 	if(w->scrollFollowsModel())
diff --git a/src/gui/treeview/linesselectionmodel.cpp b/src/gui/treeview/linesselectionmodel.cpp
index 2dc14d5..9a1ccd2 100644
--- a/src/gui/treeview/linesselectionmodel.cpp
+++ b/src/gui/treeview/linesselectionmodel.cpp
@@ -28,7 +28,8 @@ LinesSelectionModel::LinesSelectionModel(LinesModel *model)
 void
 LinesSelectionModel::setCurrentIndex(const QModelIndex &index, QItemSelectionModel::SelectionFlags command)
 {
-	m_currentLine = static_cast<LinesModel *>(model())->subtitle()->line(index.row());
+	Subtitle *sub = static_cast<LinesModel *>(model())->subtitle();
+	m_currentLine = sub ? sub->line(index.row()) : nullptr;
 	QItemSelectionModel::setCurrentIndex(index, command);
 }
 
@@ -50,6 +51,9 @@ LinesSelectionModel::select(const QItemSelection &selection, QItemSelectionModel
 		m_selection.clear();
 
 	const Subtitle *subtitle = static_cast<LinesModel *>(model())->subtitle();
+	if(!subtitle)
+		return;
+
 	QModelIndexList sel = selection.indexes();
 	while(!sel.empty()) {
 		const SubtitleLine *line = subtitle->line(sel.takeFirst().row());
@@ -83,11 +87,16 @@ LinesSelectionModel::reset()
 	QItemSelectionModel::reset();
 	m_resetInProgress = false;
 
-	if(m_currentLine)
-		QItemSelectionModel::setCurrentIndex(model()->index(m_currentLine->index(), 0), QItemSelectionModel::Current);
-
 	const LinesModel *model = static_cast<LinesModel *>(this->model());
 	Subtitle *subtitle = model->subtitle();
+	if(!subtitle) {
+		QItemSelectionModel::clear();
+		return;
+	}
+
+	if(m_currentLine)
+		QItemSelectionModel::setCurrentIndex(model->index(m_currentLine->index(), 0), QItemSelectionModel::Current);
+
 	const int lastCol = model->columnCount() - 1;
 	for(auto it = m_selection.cbegin(); it != m_selection.cend(); ++it) {
 		const SubtitleLine *line = *it;
diff --git a/src/gui/treeview/lineswidget.cpp b/src/gui/treeview/lineswidget.cpp
index 9d42ebb..7b492df 100644
--- a/src/gui/treeview/lineswidget.cpp
+++ b/src/gui/treeview/lineswidget.cpp
@@ -358,93 +358,83 @@ LinesWidget::eventFilter(QObject *object, QEvent *event)
 	return TreeView::eventFilter(object, event);
 }
 
-void
-LinesWidget::contextMenuEvent(QContextMenuEvent *e)
+inline static void
+addAppAction(QMenu *menu, const char *actionName, bool checkable=false, bool checked=false)
 {
-	SubtitleLine *referenceLine = nullptr;
-	QItemSelectionModel *selection = selectionModel();
-	for(int row = 0, rowCount = model()->rowCount(); row < rowCount; ++row) {
-		if(selection->isSelected(model()->index(row, 0))) {
-			referenceLine = model()->subtitle()->line(row);
-			break;
-		}
+	QAction *action = app()->action(actionName);
+	if(checkable) {
+		action->setCheckable(true);
+		action->setChecked(checked);
 	}
-	if(!referenceLine)
-		return;
+	menu->addAction(action);
+	if(checkable)
+		action->setCheckable(false);
+}
 
-	QList<QAction *> checkableActions;
-	auto appAction = [&](const char *actionName, bool checkable=false, bool checked=false) -> QAction * {
-		QAction *action = app()->action(actionName);
-		if(checkable) {
-			checkableActions.append(action);
-			action->setCheckable(true);
-			action->setChecked(checked);
-		}
-		return action;
-	};
+void
+LinesWidget::contextMenuEvent(QContextMenuEvent *e)
+{
+	SubtitleLine *subLine = static_cast<LinesSelectionModel *>(selectionModel())->currentLine();
 
 	QMenu menu;
-	menu.addAction(appAction(ACT_SELECT_ALL_LINES));
-	menu.addAction(appAction(ACT_EDIT_CURRENT_LINE_IN_PLACE));
+	addAppAction(&menu, ACT_SELECT_ALL_LINES);
+	addAppAction(&menu, ACT_EDIT_CURRENT_LINE_IN_PLACE);
 	menu.addSeparator();
-	menu.addAction(appAction(ACT_INSERT_BEFORE_CURRENT_LINE));
-	menu.addAction(appAction(ACT_INSERT_AFTER_CURRENT_LINE));
-	menu.addAction(appAction(ACT_REMOVE_SELECTED_LINES));
+	addAppAction(&menu, ACT_INSERT_BEFORE_CURRENT_LINE);
+	addAppAction(&menu, ACT_INSERT_AFTER_CURRENT_LINE);
+	addAppAction(&menu, ACT_REMOVE_SELECTED_LINES);
 	menu.addSeparator();
-	menu.addAction(appAction(ACT_JOIN_SELECTED_LINES));
-	menu.addAction(appAction(ACT_SPLIT_SELECTED_LINES));
+	addAppAction(&menu, ACT_JOIN_SELECTED_LINES);
+	addAppAction(&menu, ACT_SPLIT_SELECTED_LINES);
 	menu.addSeparator();
-	menu.addAction(appAction(ACT_ANCHOR_TOGGLE));
-	menu.addAction(appAction(ACT_ANCHOR_REMOVE_ALL));
+	addAppAction(&menu, ACT_ANCHOR_TOGGLE);
+	addAppAction(&menu, ACT_ANCHOR_REMOVE_ALL);
 	menu.addSeparator();
 
 	QMenu textsMenu(i18n("Texts"));
-	textsMenu.addAction(appAction(ACT_ADJUST_TEXTS));
-	textsMenu.addAction(appAction(ACT_UNBREAK_TEXTS));
-	textsMenu.addAction(appAction(ACT_SIMPLIFY_SPACES));
-	textsMenu.addAction(appAction(ACT_CHANGE_CASE));
-	textsMenu.addAction(appAction(ACT_FIX_PUNCTUATION));
-	textsMenu.addAction(appAction(ACT_TRANSLATE));
+	addAppAction(&textsMenu, ACT_ADJUST_TEXTS);
+	addAppAction(&textsMenu, ACT_UNBREAK_TEXTS);
+	addAppAction(&textsMenu, ACT_SIMPLIFY_SPACES);
+	addAppAction(&textsMenu, ACT_CHANGE_CASE);
+	addAppAction(&textsMenu, ACT_FIX_PUNCTUATION);
+	addAppAction(&textsMenu, ACT_TRANSLATE);
 	textsMenu.addSeparator();
-	textsMenu.addAction(appAction(ACT_SPELL_CHECK));
+	addAppAction(&textsMenu, ACT_SPELL_CHECK);
 	menu.addMenu(&textsMenu);
 
 	QMenu stylesMenu(i18n("Styles"));
-	const int styleFlags = referenceLine->primaryDoc()->cummulativeStyleFlags() | referenceLine->secondaryDoc()->cummulativeStyleFlags();
-	stylesMenu.addAction(appAction(ACT_TOGGLE_SELECTED_LINES_BOLD, true, styleFlags & SString::Bold));
-	stylesMenu.addAction(appAction(ACT_TOGGLE_SELECTED_LINES_ITALIC, true, styleFlags & SString::Italic));
-	stylesMenu.addAction(appAction(ACT_TOGGLE_SELECTED_LINES_UNDERLINE, true, styleFlags & SString::Underline));
-	stylesMenu.addAction(appAction(ACT_TOGGLE_SELECTED_LINES_STRIKETHROUGH, true, styleFlags & SString::StrikeThrough));
-	stylesMenu.addAction(appAction(ACT_CHANGE_SELECTED_LINES_TEXT_COLOR));
+	const int styleFlags = subLine ? subLine->primaryDoc()->cummulativeStyleFlags() | subLine->secondaryDoc()->cummulativeStyleFlags() : 0;
+	addAppAction(&stylesMenu, ACT_TOGGLE_SELECTED_LINES_BOLD, true, styleFlags & SString::Bold);
+	addAppAction(&stylesMenu, ACT_TOGGLE_SELECTED_LINES_ITALIC, true, styleFlags & SString::Italic);
+	addAppAction(&stylesMenu, ACT_TOGGLE_SELECTED_LINES_UNDERLINE, true, styleFlags & SString::Underline);
+	addAppAction(&stylesMenu, ACT_TOGGLE_SELECTED_LINES_STRIKETHROUGH, true, styleFlags & SString::StrikeThrough);
+	addAppAction(&stylesMenu, ACT_CHANGE_SELECTED_LINES_TEXT_COLOR);
 	menu.addMenu(&stylesMenu);
 
 	QMenu timesMenu(i18n("Times"));
-	timesMenu.addAction(appAction(ACT_SHIFT_SELECTED_LINES_FORWARDS));
-	timesMenu.addAction(appAction(ACT_SHIFT_SELECTED_LINES_BACKWARDS));
+	addAppAction(&timesMenu, ACT_SHIFT_SELECTED_LINES_FORWARDS);
+	addAppAction(&timesMenu, ACT_SHIFT_SELECTED_LINES_BACKWARDS);
 	timesMenu.addSeparator();
-	timesMenu.addAction(appAction(ACT_SHIFT));
-	timesMenu.addAction(appAction(ACT_DURATION_LIMITS));
-	timesMenu.addAction(appAction(ACT_AUTOMATIC_DURATIONS));
-	timesMenu.addAction(appAction(ACT_MAXIMIZE_DURATIONS));
-	timesMenu.addAction(appAction(ACT_FIX_OVERLAPPING_LINES));
+	addAppAction(&timesMenu, ACT_SHIFT);
+	addAppAction(&timesMenu, ACT_DURATION_LIMITS);
+	addAppAction(&timesMenu, ACT_AUTOMATIC_DURATIONS);
+	addAppAction(&timesMenu, ACT_MAXIMIZE_DURATIONS);
+	addAppAction(&timesMenu, ACT_FIX_OVERLAPPING_LINES);
 	menu.addMenu(&timesMenu);
 
 	QMenu errorsMenu(i18n("Errors"));
-	errorsMenu.addAction(appAction(ACT_TOGGLE_SELECTED_LINES_MARK, true, referenceLine->errorFlags() & SubtitleLine::UserMark));
+	addAppAction(&errorsMenu, ACT_TOGGLE_SELECTED_LINES_MARK, true, subLine ? subLine->errorFlags() & SubtitleLine::UserMark : 0);
 	errorsMenu.addSeparator();
-	errorsMenu.addAction(appAction(ACT_DETECT_ERRORS));
-	errorsMenu.addAction(appAction(ACT_CLEAR_ERRORS));
+	addAppAction(&errorsMenu, ACT_DETECT_ERRORS);
+	addAppAction(&errorsMenu, ACT_CLEAR_ERRORS);
 	errorsMenu.addSeparator();
-	errorsMenu.addAction(appAction(ACT_SHOW_ERRORS));
+	addAppAction(&errorsMenu, ACT_SHOW_ERRORS);
 	menu.addMenu(&errorsMenu);
 
 	m_showingContextMenu = true;
 	menu.exec(e->globalPos());
 	m_showingContextMenu = false;
 
-	foreach(QAction *action, checkableActions)
-		action->setCheckable(false);
-
 	e->ignore();
 
 	TreeView::contextMenuEvent(e);
diff --git a/src/gui/treeview/richlineedit.cpp b/src/gui/treeview/richlineedit.cpp
index 92a63a2..ebd1a9f 100644
--- a/src/gui/treeview/richlineedit.cpp
+++ b/src/gui/treeview/richlineedit.cpp
@@ -80,35 +80,35 @@ RichLineEdit::setupActions()
 	act->setIcon(QIcon::fromTheme("edit-cut"));
 	act->setText(i18n("Cut"));
 	act->setShortcuts(KStandardShortcut::cut());
-	connect(act, &QAction::triggered, [this](){ m_control->cut(); });
+	connect(act, &QAction::triggered, this, [this](){ m_control->cut(); });
 	m_actions.push_back(act);
 
 	act = new QAction(this);
 	act->setIcon(QIcon::fromTheme("edit-copy"));
 	act->setText(i18n("Copy"));
 	act->setShortcuts(KStandardShortcut::copy());
-	connect(act, &QAction::triggered, [this](){ m_control->copy(); });
+	connect(act, &QAction::triggered, this, [this](){ m_control->copy(); });
 	m_actions.push_back(act);
 
 	act = new QAction(this);
 	act->setIcon(QIcon::fromTheme("edit-paste"));
 	act->setText(i18n("Paste"));
 	act->setShortcuts(KStandardShortcut::paste());
-	connect(act, &QAction::triggered, [this](){ m_control->paste(); });
+	connect(act, &QAction::triggered, this, [this](){ m_control->paste(); });
 	m_actions.push_back(act);
 #endif
 
 	act = new QAction(this);
 	act->setIcon(QIcon::fromTheme("edit-clear"));
 	act->setText(i18nc("@action:inmenu Clear all text", "Clear"));
-	connect(act, &QAction::triggered, [this](){ m_control->clear(); });
+	connect(act, &QAction::triggered, this, [this](){ m_control->clear(); });
 	m_actions.push_back(act);
 
 	act = new QAction(this);
 	act->setIcon(QIcon::fromTheme("edit-select-all"));
 	act->setText(i18n("Select All"));
 	setupActionCommon(act, ACT_SELECT_ALL_LINES);
-	connect(act, &QAction::triggered, [this](){ m_control->selectAll(); });
+	connect(act, &QAction::triggered, this, [this](){ m_control->selectAll(); });
 	m_actions.push_back(act);
 
 	act = new QAction(this);
@@ -116,7 +116,7 @@ RichLineEdit::setupActions()
 	act->setText(i18nc("@action:inmenu Toggle bold style", "Bold"));
 	act->setCheckable(true);
 	setupActionCommon(act, ACT_TOGGLE_SELECTED_LINES_BOLD);
-	connect(act, &QAction::triggered, [this](){ m_control->toggleBold(); });
+	connect(act, &QAction::triggered, this, [this](){ m_control->toggleBold(); });
 	m_actions.push_back(act);
 
 	act = new QAction(this);
@@ -124,7 +124,7 @@ RichLineEdit::setupActions()
 	act->setText(i18nc("@action:inmenu Toggle italic style", "Italic"));
 	act->setCheckable(true);
 	setupActionCommon(act, ACT_TOGGLE_SELECTED_LINES_ITALIC);
-	connect(act, &QAction::triggered, [this](){ m_control->toggleItalic(); });
+	connect(act, &QAction::triggered, this, [this](){ m_control->toggleItalic(); });
 	m_actions.push_back(act);
 
 	act = new QAction(this);
@@ -132,7 +132,7 @@ RichLineEdit::setupActions()
 	act->setText(i18nc("@action:inmenu Toggle underline style", "Underline"));
 	act->setCheckable(true);
 	setupActionCommon(act, ACT_TOGGLE_SELECTED_LINES_UNDERLINE);
-	connect(act, &QAction::triggered, [this](){ m_control->toggleUnderline(); });
+	connect(act, &QAction::triggered, this, [this](){ m_control->toggleUnderline(); });
 	m_actions.push_back(act);
 
 	act = new QAction(this);
@@ -140,7 +140,7 @@ RichLineEdit::setupActions()
 	act->setText(i18nc("@action:inmenu Toggle strike through style", "Strike Through"));
 	act->setCheckable(true);
 	setupActionCommon(act, ACT_TOGGLE_SELECTED_LINES_STRIKETHROUGH);
-	connect(act, &QAction::triggered, [this](){ m_control->toggleStrikeOut(); });
+	connect(act, &QAction::triggered, this, [this](){ m_control->toggleStrikeOut(); });
 	m_actions.push_back(act);
 
 	act = new QAction(this);
diff --git a/src/gui/waveform/waveformwidget.cpp b/src/gui/waveform/waveformwidget.cpp
index 717be8f..cddfcfe 100644
--- a/src/gui/waveform/waveformwidget.cpp
+++ b/src/gui/waveform/waveformwidget.cpp
@@ -691,7 +691,7 @@ WaveformWidget::showContextMenu(QPoint pos)
 			}));
 		menu->addSeparator();
 		needSubtitle.append(
-			menu->addAction(i18n("Join Lines"), [&](){
+			menu->addAction(i18n("Join Lines"), this, [&](){
 				int startIndex = -1, endIndex = -1;
 				const Time startTime = rightMouseSoonerTime();
 				const Time endTime = rightMouseLaterTime();
@@ -709,13 +709,13 @@ WaveformWidget::showContextMenu(QPoint pos)
 			})
 		);
 		needCurrentLine.append(
-			menu->addAction(i18n("Split Line"), [&](){
+			menu->addAction(i18n("Split Line"), this, [&](){
 				// TODO: split the line at exact waveform mouse position
 				m_subtitle->splitLines(RangeList(Range(currentLine->index())));
 			}));
 		menu->addSeparator();
 		needCurrentLine.append(
-			menu->addAction(i18n("Toggle Anchor"), [&](){ m_subtitle->toggleLineAnchor(currentLine); }));
+			menu->addAction(i18n("Toggle Anchor"), this, [&](){ m_subtitle->toggleLineAnchor(currentLine); }));
 		menu->addAction(app->action(ACT_ANCHOR_REMOVE_ALL));
 		menu->addSeparator();
 		actionManager->addAction(
diff --git a/src/main.cpp b/src/main.cpp
index c33d2cb..79b0f6c 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -130,7 +130,7 @@ handleCommandLine(SubtitleComposer::Application &app, KAboutData &aboutData)
 
 	if(!fileSub.isEmpty())
 		app.openSubtitle(System::urlFromPath(fileSub));
-	else if(!fileTrans.isEmpty())
+	else
 		app.newSubtitle();
 	if(!fileTrans.isEmpty())
 		app.openSubtitleTr(System::urlFromPath(fileTrans));
@@ -183,6 +183,9 @@ setupIconTheme(int argc, char **argv)
 
 	if(platformThemeName == QStringLiteral("lxqt"))
 		QIcon::setThemeSearchPaths(QIcon::themeSearchPaths() << fallbackPaths);
+#else
+	Q_UNUSED(argc)
+	Q_UNUSED(argv)
 #endif
 }
 
diff --git a/src/scripting/CMakeLists.txt b/src/scripting/CMakeLists.txt
index 7c9b2ab..d0f3bd1 100644
--- a/src/scripting/CMakeLists.txt
+++ b/src/scripting/CMakeLists.txt
@@ -1,10 +1,8 @@
-FILE(GLOB ruby_examples examples/*.rb)
-FILE(GLOB python_examples examples/*.py)
 FILE(GLOB javascript_examples examples/*.js)
 FILE(GLOB header_files scripting_*.h)
 
 INSTALL(FILES
-	${ruby_examples} ${python_examples} ${javascript_examples} examples/README
+	${javascript_examples} examples/README
 	DESTINATION ${DATA_INSTALL_DIR}/subtitlecomposer/scripts
 )
 
diff --git a/src/scripting/examples/example_capitalize_all_lines.js b/src/scripting/examples/example_capitalize_all_lines.js
index 5fe5df8..fe2d9bd 100644
--- a/src/scripting/examples/example_capitalize_all_lines.js
+++ b/src/scripting/examples/example_capitalize_all_lines.js
@@ -1,13 +1,18 @@
 /*
-    SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
+	SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
 
-    SPDX-License-Identifier: GPL-2.0-or-later
+	SPDX-License-Identifier: GPL-2.0-or-later
+
+	@category Examples
+	@name Capitalize All Lines
+	@version 1.0
+	@summary Example script to capitalize first letter of each subtitle line.
+	@author SubtitleComposer Team
 */
 
-s = subtitle.instance();
-for ( var lineIndex = 0, linesCount = s.linesCount(); lineIndex < linesCount; ++lineIndex )
-{
-	var line = s.line( lineIndex );
-	var text = line.primaryText();
-	line.setPrimaryText( text.left( 1 ).toUpper().append( text.mid( 1 ) ) );
+let s = subtitle.instance();
+for(let i = 0, n = s.linesCount(); i < n; i++) {
+	let line = s.line(i);
+	let text = line.primaryText();
+	line.setPrimaryText(text.left(1).toUpper().append(text.mid(1)));
 }
diff --git a/src/scripting/examples/example_capitalize_all_lines.py b/src/scripting/examples/example_capitalize_all_lines.py
deleted file mode 100644
index 7472134..0000000
--- a/src/scripting/examples/example_capitalize_all_lines.py
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-# SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-import ranges
-import subtitle
-
-s = subtitle.instance()
-for line_index in range( 0, s.linesCount() ):
-	line = s.line( line_index )
-	text = line.primaryText()
-	line.setPrimaryText( text.left( 1 ).toUpper().append( text.mid( 1 ) ) )
diff --git a/src/scripting/examples/example_capitalize_all_lines.rb b/src/scripting/examples/example_capitalize_all_lines.rb
deleted file mode 100644
index cb53190..0000000
--- a/src/scripting/examples/example_capitalize_all_lines.rb
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/usr/bin/env ruby
-
-# SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-require "ranges"
-require "subtitle"
-
-subtitle = Subtitle.instance()
-for line_index in 0..subtitle.linesCount()-1
-	line = subtitle.line( line_index )
-	text = line.primaryText()
-	line.setPrimaryText( text.left( 1 ).toUpper().append( text.mid( 1 ) ) )
-end
diff --git a/src/scripting/examples/example_iterate_selection.js b/src/scripting/examples/example_iterate_selection.js
index f33fc17..dcc8ebe 100644
--- a/src/scripting/examples/example_iterate_selection.js
+++ b/src/scripting/examples/example_iterate_selection.js
@@ -1,18 +1,23 @@
 /*
-    SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
+	SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
 
-    SPDX-License-Identifier: GPL-2.0-or-later
+	SPDX-License-Identifier: GPL-2.0-or-later
+
+	@category Examples
+	@name Iterate Selected Lines
+	@version 1.0
+	@summary Example script to iterate over selected lines and show their text.
+	@author SubtitleComposer Team
 */
 
-function RangesIterator( rangeList, forward )
-{
-	this.forward = typeof( forward ) == "undefined" ? true : forward;
+function RangesIterator(rangeList, forward) {
+	this.forward = forward === undefined ? true : forward;
 	this.rangeList = rangeList;
 	this.rangeIndex = this.forward ? -1 : this.rangeList.rangesCount()
 
 	this.current = function() {
 		return this.rangeIndex >= 0 && this.rangeIndex < this.rangeList.rangesCount() ?
- 			this.rangeList.range( this.rangeIndex ) :
+ 			this.rangeList.range(this.rangeIndex) :
 			null;
 	};
 
@@ -28,53 +33,46 @@ function RangesIterator( rangeList, forward )
 	};
 }
 
-function LinesIterator( rangeList, forward )
-{
-	this.forward = typeof( forward ) == "undefined" ? true : forward;
-	this.rangesIt = new RangesIterator( rangeList, this.forward );
+function LinesIterator(rangeList, forward) {
+	this.forward = forward === undefined ? true : forward;
+	this.rangesIt = new RangesIterator(rangeList, this.forward);
 	this.lineIndex = -1;
 	this.subtitle = subtitle.instance();
 
 	this.current = function() {
-		var range = this.rangesIt.current();
-		return range != null && this.lineIndex >= range.start() && this.lineIndex < range.end()?
- 			this.subtitle.line( this.lineIndex ) :
-			null;
+		let range = this.rangesIt.current();
+		return range != null && this.lineIndex >= range.start() && this.lineIndex < range.end()
+				? this.subtitle.line(this.lineIndex) : null;
 	};
 
 	this.hasNext = function() {
-		return this.rangesIt.hasNext() || (this.rangesIt.current() && (this.forward ?
-			this.lineIndex < this.rangesIt.current().end() :
-			this.lineIndex > this.rangesIt.current().start()));
+		return this.rangesIt.hasNext() || (this.rangesIt.current() &&
+			(this.forward ? this.lineIndex < this.rangesIt.current().end() : this.lineIndex > this.rangesIt.current().start())
+			);
 	};
 
 	this.next = function() {
-		var currentRange = this.rangesIt.current();
-		if ( currentRange == null
-			 || (forward && this.lineIndex == currentRange.end())
-			 || (! forward && this.lineIndex == currentRange.start()) )
-		{
-			if ( ! this.rangesIt.hasNext() )
+		let currentRange = this.rangesIt.current();
+		if(currentRange == null || (this.lineIndex == (forward ? currentRange.end() : currentRange.start()))) {
+			if(!this.rangesIt.hasNext())
 				return null;
 			currentRange = this.rangesIt.next();
 			this.lineIndex = this.forward ? currentRange.start() : currentRange.end();
-		}
-		else
+		} else {
 			this.lineIndex += this.forward ? 1 : -1;
-		return this.subtitle.line( this.lineIndex )
+		}
+		return this.subtitle.line(this.lineIndex);
 	};
 }
 
-var rangesIt = new RangesIterator( ranges.newSelectionRangeList(), true );
-while ( rangesIt.hasNext() )
-{
-	var range = rangesIt.next();
+let rangesIt = new RangesIterator(ranges.newSelectionRangeList(), true);
+while(rangesIt.hasNext()) {
+	let range = rangesIt.next();
 	debug.information( range.start().toString() + ":" + range.end().toString() );
 }
 
-var linesIt = new LinesIterator( ranges.newSelectionRangeList(), false );
-while ( linesIt.hasNext() )
-{
-	var line = linesIt.next();
-	debug.information( "Plain text: " + line.plainPrimaryText() + "\n\nRich Text: " + line.richPrimaryText() );
+let linesIt = new LinesIterator( ranges.newSelectionRangeList(), false );
+while(linesIt.hasNext()) {
+	let line = linesIt.next();
+	debug.information("Plain text: " + line.plainPrimaryText() + "\n\nRich Text: " + line.richPrimaryText());
 }
diff --git a/src/scripting/examples/example_iterate_selection.py b/src/scripting/examples/example_iterate_selection.py
deleted file mode 100644
index 3bf568c..0000000
--- a/src/scripting/examples/example_iterate_selection.py
+++ /dev/null
@@ -1,29 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-# SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-import ranges
-import subtitle
-import debug
-
-def each_range( range_list, forward=True ):
-	r = range( 0, range_list.rangesCount() )
-	if not forward: r.reverse()
-	for range_index in r:
-		yield range_list.range( range_index )
-
-def each_line( range_list, forward=True ):
-	for r in each_range( range_list, forward ):
-		r2 = range( r.start(), r.end() + 1 )
-		if not forward: r2.reverse()
-		for line_index in r2:
-			yield subtitle.instance().line( line_index )
-
-for r in each_range( ranges.newSelectionRangeList(), True ):
-	debug.information( str( r.start() ) + ":" + str( r.end() ) )
-
-for l in each_line( ranges.newSelectionRangeList(), False ):
-	debug.information( "Plain text: " + l.plainPrimaryText() + "\n\nRich Text: " + l.richPrimaryText() )
diff --git a/src/scripting/examples/example_iterate_selection.rb b/src/scripting/examples/example_iterate_selection.rb
deleted file mode 100644
index c0478dd..0000000
--- a/src/scripting/examples/example_iterate_selection.rb
+++ /dev/null
@@ -1,36 +0,0 @@
-#!/usr/bin/env ruby
-
-# SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-require "ranges"
-require "subtitle"
-require "debug"
-
-def each_range( range_list, forward=true )
-	range_indexes = 0..range_list.rangesCount()-1
-	range_indexes = range_indexes.to_a().reverse() if ! forward
-	for range_index in range_indexes
-		yield range_list.range( range_index )
-	end
-end
-
-def each_line( range_list, forward=true )
-	subtitle = Subtitle.instance()
-	each_range( range_list, forward ) do |range|
-		line_indexes = range.start()..range.end()
-		line_indexes = line_indexes.to_a().reverse() if ! forward
-		for line_index in line_indexes
-			yield subtitle.line( line_index )
-		end
-	end
-end
-
-each_range( Ranges.newSelectionRangeList(), true ) do |range|
-	Debug.information( "#{range.start}:#{range.end}")
-end
-
-each_line( Ranges.newSelectionRangeList(), false ) do |line|
-	Debug.information( "Plain text: " + line.plainPrimaryText() + "\n\nRich Text: " + line.richPrimaryText() )
-end
diff --git a/src/scripting/examples/example_remove_impair_lines.js b/src/scripting/examples/example_remove_impair_lines.js
deleted file mode 100644
index 0e029ef..0000000
--- a/src/scripting/examples/example_remove_impair_lines.js
+++ /dev/null
@@ -1,12 +0,0 @@
-/*
-    SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-
-    SPDX-License-Identifier: GPL-2.0-or-later
-*/
-
-s = subtitle.instance();
-for ( var lineIndex = s.linesCount() - 1; lineIndex >= 0; --lineIndex )
-{
-	if ( lineIndex % 2 == 0 )
-		s.removeLine( lineIndex );
-}
diff --git a/src/scripting/examples/example_remove_impair_lines.py b/src/scripting/examples/example_remove_impair_lines.py
deleted file mode 100644
index 2a7127d..0000000
--- a/src/scripting/examples/example_remove_impair_lines.py
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-# SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-import subtitle
-
-s = subtitle.instance()
-reversed_indexes = range( 0, s.linesCount() );
-reversed_indexes.reverse()
-for line_index in reversed_indexes:
-	if ( line_index % 2 == 0 ):
-		s.removeLine( line_index )
diff --git a/src/scripting/examples/example_remove_impair_lines.rb b/src/scripting/examples/example_remove_impair_lines.rb
deleted file mode 100644
index f50f656..0000000
--- a/src/scripting/examples/example_remove_impair_lines.rb
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/usr/bin/env ruby
-
-# SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-require "subtitle"
-
-subtitle = Subtitle.instance()
-for line_index in (0..subtitle.linesCount()-1).to_a().reverse()
-	subtitle.removeLine( line_index ) if ( line_index % 2 == 0 )
-end
diff --git a/src/scripting/examples/example_remove_odd_lines.js b/src/scripting/examples/example_remove_odd_lines.js
new file mode 100644
index 0000000..6202ee4
--- /dev/null
+++ b/src/scripting/examples/example_remove_odd_lines.js
@@ -0,0 +1,17 @@
+/*
+	SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
+
+	SPDX-License-Identifier: GPL-2.0-or-later
+
+	@category Examples
+	@name Remove Odd Lines
+	@version 1.0
+	@summary Example script to remove odd lines.
+	@author SubtitleComposer Team
+*/
+
+let s = subtitle.instance();
+for(let i = s.linesCount() - 1; i >= 0; i--) {
+	if(i % 2 == 0)
+		s.removeLine(i);
+}
diff --git a/src/scripting/examples/example_trim_to_selection.js b/src/scripting/examples/example_trim_to_selection.js
index edb97d6..1f16dd4 100644
--- a/src/scripting/examples/example_trim_to_selection.js
+++ b/src/scripting/examples/example_trim_to_selection.js
@@ -1,7 +1,13 @@
 /*
-    SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
+	SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
 
-    SPDX-License-Identifier: GPL-2.0-or-later
+	SPDX-License-Identifier: GPL-2.0-or-later
+
+	@category Examples
+	@name Remove Unselected Lines
+	@version 1.0
+	@summary Example script to remove all lines except the selected ones.
+	@author SubtitleComposer Team
 */
 
-subtitle.instance().removeLines( ranges.newSelectionRangeList().complement() );
+subtitle.instance().removeLines(ranges.newSelectionRangeList().complement());
diff --git a/src/scripting/examples/example_trim_to_selection.py b/src/scripting/examples/example_trim_to_selection.py
deleted file mode 100644
index f80899d..0000000
--- a/src/scripting/examples/example_trim_to_selection.py
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-# SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-import ranges
-import subtitle
-
-subtitle.instance().removeLines( ranges.newSelectionRangeList().complement() )
diff --git a/src/scripting/examples/example_trim_to_selection.rb b/src/scripting/examples/example_trim_to_selection.rb
deleted file mode 100644
index 68e563b..0000000
--- a/src/scripting/examples/example_trim_to_selection.rb
+++ /dev/null
@@ -1,10 +0,0 @@
-#!/usr/bin/env ruby
-
-# SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-require "ranges"
-require "subtitle"
-
-Subtitle.instance().removeLines( Ranges.newSelectionRangeList().complement() )
diff --git a/src/scripting/examples/fix_dialog_cues.py b/src/scripting/examples/fix_dialog_cues.py
deleted file mode 100644
index 09da98f..0000000
--- a/src/scripting/examples/fix_dialog_cues.py
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-# SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-import ranges
-import subtitle
-import strings
-import debug
-
-def each_range( range_list, forward=True ):
-	r = range( 0, range_list.rangesCount() )
-	if not forward: r.reverse()
-	for range_index in r:
-		yield range_list.range( range_index )
-
-def each_line( range_list, forward=True ):
-	for r in each_range( range_list, forward ):
-		r2 = range( r.start(), r.end() + 1 )
-		if not forward: r2.reverse()
-		for line_index in r2:
-			yield subtitle.instance().line( line_index )
-
-after = strings.newString( "\\1-" )
-for line in each_line( ranges.newSelectionRangeList(), False ):
-	line.setPrimaryText( line.primaryText().replaceAll( "(^|\n)- *", after, True, True ) )
diff --git a/src/scripting/examples/prepare_RTL_release.py b/src/scripting/examples/prepare_RTL_release.py
deleted file mode 100644
index da7cd7b..0000000
--- a/src/scripting/examples/prepare_RTL_release.py
+++ /dev/null
@@ -1,37 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-# SPDX-FileCopyrightText: 2018 Safa AlFulaij <safa1996alfulaij@gmail.com>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-import ranges
-import subtitle
-
-s = subtitle.instance()
-
-# First add a “working” line
-s.insertNewLine(s.linesCount(), False)
-
-# Keep track. 2 lines = line 0 line 1
-tempLine = s.line(s.linesCount()-1)
-
-# All the lines except the last one
-for line_index in range(0, s.linesCount()-1):
-	line = s.line( line_index )
-
-	# To store the modefied sublines
-	combinedArray = []
-
-	# each line in the subtitle line
-	for eachSubLine in line.richPrimaryText().split("\n"):
-		tempLine.setRichPrimaryText(eachSubLine)
-		if tempLine.isRightToLeft():
-			combinedArray.append(u"\u202B%s"%eachSubLine.decode('utf8')) # Add RLE for RTL lines
-		else:
-			combinedArray.append(u"\u202A%s"%eachSubLine.decode('utf8')) # Add LRE for LTR lines
-
-	line.setRichPrimaryText("\n".join(combinedArray))
-
-# Delete the temp line
-s.removeLine(s.linesCount()-1)
diff --git a/src/scripting/examples/remove_hearing_impaired_text.js b/src/scripting/examples/remove_hearing_impaired_text.js
index a14b4e0..459b9c4 100644
--- a/src/scripting/examples/remove_hearing_impaired_text.js
+++ b/src/scripting/examples/remove_hearing_impaired_text.js
@@ -1,7 +1,13 @@
 /*
-    SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
+	SPDX-FileCopyrightText: 2007-2009 Sergio Pistone <sergio_pistone@yahoo.com.ar>
+	SPDX-FileCopyrightText: 2021 Mladen Milinkovic <maxrd2@smoothware.net>
 
-    SPDX-License-Identifier: GPL-2.0-or-later
+	SPDX-License-Identifier: GPL-2.0-or-later
+
+	@name Remove Hearing Impaired Text
+	@version 1.0
+	@summary Remove hearing impaired text from subtitle lines.
+	@author SubtitleComposer Team
 */
 
 var s = subtitle.instance();
@@ -12,7 +18,8 @@ for(var i = s.linesCount() - 1; i >= 0; i--) {
 			.replace(/\s*\[[^\]]+\]\s*/, ' ')
 			.replace(/^(<.*>)?.*:\s*/, '$1')
 			.replace(/(^\s*|\s*$)/, '');
-	if(text.replace(/(<[^>]+>|\s)/, '') == '')
+
+	if(text.replace(/(<[^>]+>|\s)/, '') === '')
 		s.removeLine(i);
 	else
 		line.setRichPrimaryText(text);
diff --git a/src/scripting/examples/undo_RTL_release.py b/src/scripting/examples/undo_RTL_release.py
deleted file mode 100644
index 5598821..0000000
--- a/src/scripting/examples/undo_RTL_release.py
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-# SPDX-FileCopyrightText: 2018 Safa AlFulaij <safa1996alfulaij@gmail.com>
-#
-# SPDX-License-Identifier: GPL-2.0-or-later
-
-import ranges
-import subtitle
-
-s = subtitle.instance()
-
-# All the lines
-for line_index in range(0, s.linesCount()):
-	line = s.line( line_index )
-
-	# To store the modefied sublines
-	combinedArray = []
-
-	# each line in the subtitle line
-	for eachSubLine in line.richPrimaryText().split("\n"):
-		combinedArray.append(eachSubLine.decode('utf8')[1:]) # Remove the first character (RLE/LRE)
-
-	line.setRichPrimaryText("\n".join(combinedArray))
diff --git a/src/scripting/scripting_rangelist.cpp b/src/scripting/scripting_rangelist.cpp
index 8135d04..639229f 100644
--- a/src/scripting/scripting_rangelist.cpp
+++ b/src/scripting/scripting_rangelist.cpp
@@ -80,7 +80,7 @@ Scripting::RangeList::trimToIndex(int index)
 }
 
 void
-Scripting::RangeList::trimToRange(const QObject *object)
+Scripting::RangeList::trimToRange(QObject *object)
 {
 	if(const Scripting::Range * range = qobject_cast<const Scripting::Range *>(object))
 		m_backend.trimToRange(range->m_backend);
@@ -95,7 +95,7 @@ Scripting::RangeList::addIndex(int index)
 }
 
 QObject *
-Scripting::RangeList::addRange(const QObject *object)
+Scripting::RangeList::addRange(QObject *object)
 {
 	if(const Scripting::Range * range = qobject_cast<const Scripting::Range *>(object))
 		m_backend << range->m_backend;
diff --git a/src/scripting/scripting_rangelist.h b/src/scripting/scripting_rangelist.h
index 57686af..e0be47a 100644
--- a/src/scripting/scripting_rangelist.h
+++ b/src/scripting/scripting_rangelist.h
@@ -36,10 +36,10 @@ public slots:
 	void clear();
 
 	void trimToIndex(int index);
-	void trimToRange(const QObject *range);
+	void trimToRange(QObject *range);
 
 	QObject * addIndex(int index);
-	QObject * addRange(const QObject *range);
+	QObject * addRange(QObject *range);
 
 	void shiftIndexesForwards(int fromIndex, int delta, bool fillSplitGap);
 	void shiftIndexesBackwards(int fromIndex, int delta);
diff --git a/src/scripting/scripting_subtitle.cpp b/src/scripting/scripting_subtitle.cpp
index 1bc8bb1..f8cb94a 100644
--- a/src/scripting/scripting_subtitle.cpp
+++ b/src/scripting/scripting_subtitle.cpp
@@ -117,64 +117,64 @@ Scripting::Subtitle::removeLine(int index, int target)
 }
 
 void
-Scripting::Subtitle::removeLines(const QObject *ranges, int target)
+Scripting::Subtitle::removeLines(QObject *ranges, int target)
 {
 	static const int opDefault = Both;
 	m_backend->removeLines(toRangesList(ranges), toTextTarget(target, opDefault));
 }
 
 void
-Scripting::Subtitle::swapTexts(const QObject *ranges)
+Scripting::Subtitle::swapTexts(QObject *ranges)
 {
 	m_backend->swapTexts(toRangesList(ranges));
 }
 
 void
-Scripting::Subtitle::splitLines(const QObject *ranges)
+Scripting::Subtitle::splitLines(QObject *ranges)
 {
 	m_backend->splitLines(toRangesList(ranges));
 }
 
 void
-Scripting::Subtitle::joinLines(const QObject *ranges)
+Scripting::Subtitle::joinLines(QObject *ranges)
 {
 	m_backend->joinLines(toRangesList(ranges));
 }
 
 void
-Scripting::Subtitle::shiftLines(const QObject *ranges, int msecs)
+Scripting::Subtitle::shiftLines(QObject *ranges, int msecs)
 {
 	m_backend->shiftLines(toRangesList(ranges), msecs);
 }
 
 void
-Scripting::Subtitle::adjustLines(const QObject *object, int firstTime, int lastTime)
+Scripting::Subtitle::adjustLines(QObject *object, int firstTime, int lastTime)
 {
 	if(const Scripting::Range * range = qobject_cast<const Scripting::Range *>(object))
 		m_backend->adjustLines(range->m_backend, firstTime, lastTime);
 }
 
 void
-Scripting::Subtitle::sortLines(const QObject *object)
+Scripting::Subtitle::sortLines(QObject *object)
 {
 	if(const Scripting::Range * range = qobject_cast<const Scripting::Range *>(object))
 		m_backend->sortLines(range->m_backend);
 }
 
 void
-Scripting::Subtitle::applyDurationLimits(const QObject *ranges, int minDuration, int maxDuration, bool canOverlap)
+Scripting::Subtitle::applyDurationLimits(QObject *ranges, int minDuration, int maxDuration, bool canOverlap)
 {
 	m_backend->applyDurationLimits(toRangesList(ranges), minDuration, maxDuration, canOverlap);
 }
 
 void
-Scripting::Subtitle::setMaximumDurations(const QObject *ranges)
+Scripting::Subtitle::setMaximumDurations(QObject *ranges)
 {
 	m_backend->setMaximumDurations(toRangesList(ranges));
 }
 
 void
-Scripting::Subtitle::setAutoDurations(const QObject *ranges, int msecsPerChar, int msecsPerWord, int msecsPerLine, bool canOverlap, int calculationTarget)
+Scripting::Subtitle::setAutoDurations(QObject *ranges, int msecsPerChar, int msecsPerWord, int msecsPerLine, bool canOverlap, int calculationTarget)
 {
 	const int opDefault = app()->translationMode() ? Both : Primary;
 
@@ -182,87 +182,87 @@ Scripting::Subtitle::setAutoDurations(const QObject *ranges, int msecsPerChar, i
 }
 
 void
-Scripting::Subtitle::fixOverlappingLines(const QObject *ranges, int minInterval)
+Scripting::Subtitle::fixOverlappingLines(QObject *ranges, int minInterval)
 {
 	m_backend->fixOverlappingLines(toRangesList(ranges), minInterval);
 }
 
 void
-Scripting::Subtitle::fixPunctuation(const QObject *ranges, bool spaces, bool quotes, bool englishI, bool ellipsis, int target)
+Scripting::Subtitle::fixPunctuation(QObject *ranges, bool spaces, bool quotes, bool englishI, bool ellipsis, int target)
 {
 	const int opDefault = app()->translationMode() ? Both : Primary;
 	m_backend->fixPunctuation(toRangesList(ranges), spaces, quotes, englishI, ellipsis, toTextTarget(target, opDefault));
 }
 
 void
-Scripting::Subtitle::lowerCase(const QObject *ranges, int target)
+Scripting::Subtitle::lowerCase(QObject *ranges, int target)
 {
 	const int opDefault = app()->translationMode() ? Both : Primary;
 	m_backend->lowerCase(toRangesList(ranges), toTextTarget(target, opDefault));
 }
 
 void
-Scripting::Subtitle::upperCase(const QObject *ranges, int target)
+Scripting::Subtitle::upperCase(QObject *ranges, int target)
 {
 	const int opDefault = app()->translationMode() ? Both : Primary;
 	m_backend->upperCase(toRangesList(ranges), toTextTarget(target, opDefault));
 }
 
 void
-Scripting::Subtitle::titleCase(const QObject *ranges, bool lowerFirst, int target)
+Scripting::Subtitle::titleCase(QObject *ranges, bool lowerFirst, int target)
 {
 	const int opDefault = app()->translationMode() ? Both : Primary;
 	m_backend->titleCase(toRangesList(ranges), lowerFirst, toTextTarget(target, opDefault));
 }
 
 void
-Scripting::Subtitle::sentenceCase(const QObject *ranges, bool lowerFirst, int target)
+Scripting::Subtitle::sentenceCase(QObject *ranges, bool lowerFirst, int target)
 {
 	const int opDefault = app()->translationMode() ? Both : Primary;
 	m_backend->sentenceCase(toRangesList(ranges), lowerFirst, toTextTarget(target, opDefault));
 }
 
 void
-Scripting::Subtitle::breakLines(const QObject *ranges, int minLengthForLineBreak, int target)
+Scripting::Subtitle::breakLines(QObject *ranges, int minLengthForLineBreak, int target)
 {
 	const int opDefault = app()->translationMode() ? Both : Primary;
 	m_backend->breakLines(toRangesList(ranges), minLengthForLineBreak, toTextTarget(target, opDefault));
 }
 
 void
-Scripting::Subtitle::unbreakTexts(const QObject *ranges, int target)
+Scripting::Subtitle::unbreakTexts(QObject *ranges, int target)
 {
 	const int opDefault = app()->translationMode() ? Both : Primary;
 	m_backend->unbreakTexts(toRangesList(ranges), toTextTarget(target, opDefault));
 }
 
 void
-Scripting::Subtitle::simplifyTextWhiteSpace(const QObject *ranges, int target)
+Scripting::Subtitle::simplifyTextWhiteSpace(QObject *ranges, int target)
 {
 	const int opDefault = app()->translationMode() ? Both : Primary;
 	m_backend->simplifyTextWhiteSpace(toRangesList(ranges), toTextTarget(target, opDefault));
 }
 
 void
-Scripting::Subtitle::setMarked(const QObject *ranges, bool value)
+Scripting::Subtitle::setMarked(QObject *ranges, bool value)
 {
 	m_backend->setMarked(toRangesList(ranges), value);
 }
 
 void
-Scripting::Subtitle::clearErrors(const QObject *ranges, int errorFlags)
+Scripting::Subtitle::clearErrors(QObject *ranges, int errorFlags)
 {
 	m_backend->clearErrors(toRangesList(ranges), errorFlags);
 }
 
 void
-Scripting::Subtitle::checkErrors(const QObject *ranges, int errorFlags)
+Scripting::Subtitle::checkErrors(QObject *ranges, int errorFlags)
 {
 	m_backend->checkErrors(toRangesList(ranges), errorFlags);
 }
 
 void
-Scripting::Subtitle::recheckErrors(const QObject *ranges)
+Scripting::Subtitle::recheckErrors(QObject *ranges)
 {
 	m_backend->recheckErrors(toRangesList(ranges));
 }
diff --git a/src/scripting/scripting_subtitle.h b/src/scripting/scripting_subtitle.h
index 57631b7..6a36884 100644
--- a/src/scripting/scripting_subtitle.h
+++ b/src/scripting/scripting_subtitle.h
@@ -41,41 +41,41 @@ public slots:
 
 	SubtitleLine * insertNewLine(int index, bool timeAfter, int target = -1);
 	void removeLine(int index, int target = -1);
-	void removeLines(const QObject *ranges, int target = -1);
+	void removeLines(QObject *ranges, int target = -1);
 
-	void swapTexts(const QObject *ranges);
+	void swapTexts(QObject *ranges);
 
-	void splitLines(const QObject *ranges);
-	void joinLines(const QObject *ranges);
+	void splitLines(QObject *ranges);
+	void joinLines(QObject *ranges);
 
-	void shiftLines(const QObject *ranges, int msecs);
-	void adjustLines(const QObject *range, int firstTime, int lastTime);
-	void sortLines(const QObject *range);
+	void shiftLines(QObject *ranges, int msecs);
+	void adjustLines(QObject *range, int firstTime, int lastTime);
+	void sortLines(QObject *range);
 
-	void applyDurationLimits(const QObject *ranges, int minDuration, int maxDuration, bool canOverlap);
-	void setMaximumDurations(const QObject *ranges);
-	void setAutoDurations(const QObject *ranges, int msecsPerChar, int msecsPerWord, int msecsPerLine, bool canOverlap, int calculationTarget = -1);
+	void applyDurationLimits(QObject *ranges, int minDuration, int maxDuration, bool canOverlap);
+	void setMaximumDurations(QObject *ranges);
+	void setAutoDurations(QObject *ranges, int msecsPerChar, int msecsPerWord, int msecsPerLine, bool canOverlap, int calculationTarget = -1);
 
-	void fixOverlappingLines(const QObject *ranges, int minInterval = 100);
+	void fixOverlappingLines(QObject *ranges, int minInterval = 100);
 
-	void fixPunctuation(const QObject *ranges, bool spaces, bool quotes, bool englishI, bool ellipsis, int target = -1);
+	void fixPunctuation(QObject *ranges, bool spaces, bool quotes, bool englishI, bool ellipsis, int target = -1);
 
-	void lowerCase(const QObject *ranges, int target = -1);
-	void upperCase(const QObject *ranges, int target = -1);
-	void titleCase(const QObject *ranges, bool lowerFirst, int target = -1);
-	void sentenceCase(const QObject *ranges, bool lowerFirst, int target = -1);
+	void lowerCase(QObject *ranges, int target = -1);
+	void upperCase(QObject *ranges, int target = -1);
+	void titleCase(QObject *ranges, bool lowerFirst, int target = -1);
+	void sentenceCase(QObject *ranges, bool lowerFirst, int target = -1);
 
-	void breakLines(const QObject *ranges, int minLengthForLineBreak, int target = -1);
-	void unbreakTexts(const QObject *ranges, int target = -1);
-	void simplifyTextWhiteSpace(const QObject *ranges, int target = -1);
+	void breakLines(QObject *ranges, int minLengthForLineBreak, int target = -1);
+	void unbreakTexts(QObject *ranges, int target = -1);
+	void simplifyTextWhiteSpace(QObject *ranges, int target = -1);
 
-	void setMarked(const QObject *ranges, bool value);
+	void setMarked(QObject *ranges, bool value);
 
-	void clearErrors(const QObject *ranges, int errorFlags);
+	void clearErrors(QObject *ranges, int errorFlags);
 
-	void checkErrors(const QObject *ranges, int errorFlags);
+	void checkErrors(QObject *ranges, int errorFlags);
 
-	void recheckErrors(const QObject *ranges);
+	void recheckErrors(QObject *ranges);
 
 private:
 	static SubtitleComposer::RangeList toRangesList(const QObject *object);
diff --git a/src/scripting/scripting_subtitleline.cpp b/src/scripting/scripting_subtitleline.cpp
index e1ebc8f..fd8fba1 100644
--- a/src/scripting/scripting_subtitleline.cpp
+++ b/src/scripting/scripting_subtitleline.cpp
@@ -81,7 +81,7 @@ Scripting::SubtitleLine::primaryText() const
 }
 
 void
-Scripting::SubtitleLine::setPrimaryText(const QObject *object)
+Scripting::SubtitleLine::setPrimaryText(QObject *object)
 {
 	const Scripting::SString *string = qobject_cast<const Scripting::SString *>(object);
 	if(string)
@@ -139,7 +139,7 @@ Scripting::SubtitleLine::secondaryText() const
 }
 
 void
-Scripting::SubtitleLine::setSecondaryText(const QObject *object)
+Scripting::SubtitleLine::setSecondaryText(QObject *object)
 {
 	if(app()->translationMode()) {
 		const Scripting::SString *string = qobject_cast<const Scripting::SString *>(object);
diff --git a/src/scripting/scripting_subtitleline.h b/src/scripting/scripting_subtitleline.h
index 81d5c00..bf9aed4 100644
--- a/src/scripting/scripting_subtitleline.h
+++ b/src/scripting/scripting_subtitleline.h
@@ -36,7 +36,7 @@ public slots:
 	int primaryLines() const;
 
 	QObject * primaryText() const;
-	void setPrimaryText(const QObject *text);
+	void setPrimaryText(QObject *text);
 	QString plainPrimaryText() const;
 	void setPlainPrimaryText(const QString &plainText);
 	QString richPrimaryText() const;
@@ -47,7 +47,7 @@ public slots:
 	int secondaryLines() const;
 
 	QObject * secondaryText() const;
-	void setSecondaryText(const QObject *text);
+	void setSecondaryText(QObject *text);
 	QString plainSecondaryText() const;
 	void setPlainSecondaryText(const QString &plainText);
 	QString richSecondaryText() const;
diff --git a/src/scripting/scriptsmanager.cpp b/src/scripting/scriptsmanager.cpp
index 8931d07..6043f7d 100644
--- a/src/scripting/scriptsmanager.cpp
+++ b/src/scripting/scriptsmanager.cpp
@@ -17,18 +17,21 @@
 #include "actions/useraction.h"
 #include "actions/useractionnames.h"
 #include "dialogs/textinputdialog.h"
+#include "helpers/common.h"
 #include "helpers/fileloadhelper.h"
 #include "helpers/filetrasher.h"
 #include "gui/treeview/treeview.h"
 
-#include <QStringListModel>
+#include <QAbstractItemModel>
 #include <QStandardPaths>
 #include <QDialog>
 #include <QFileDialog>
+#include <QJSEngine>
 #include <QMenuBar>
 #include <QMenu>
 #include <QDesktopServices>
 #include <QKeyEvent>
+#include <QStringBuilder>
 
 #include <KMessageBox>
 #include <KRun>
@@ -40,80 +43,369 @@
 #include <KIO/JobUiDelegate>
 #endif
 
-#include <kross/core/manager.h>
-#include <kross/core/interpreter.h>
-#include <kross/core/action.h>
+inline static const QDir &
+userScriptDir()
+{
+	static const QDir *dir = nullptr;
+	if(dir == nullptr) {
+		const QString userScriptDirName = $("scripts");
+		static QDir d(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation));
+		if(!d.exists(userScriptDirName))
+			d.mkpath(userScriptDirName);
+		d.cd(userScriptDirName);
+		dir = &d;
+	}
+	return *dir;
+}
 
 namespace SubtitleComposer {
-class InstalledScriptsModel : public QStringListModel
+class SCScript
 {
+	friend class InstalledScriptsModel;
+
+	SCScript(const QString &path, const QString &name)
+		: m_name(name),
+		  m_path(path),
+		  m_isScript(name.right(3) == $(".js")),
+		  m_title(name)
+	{
+		if(m_isScript)
+			initScript();
+		else
+			m_category = i18n("Non-Script Files");
+	}
+
+	void initScript()
+	{
+		const QString script = content();
+
+		QRegularExpressionMatch m;
+		staticRE$(reCat, "@category\\s+(.+)\\s*$", REm);
+		if((m = reCat.match(script)).hasMatch())
+			m_category = m.captured(1);
+		staticRE$(reName, "@name\\s+(.+)\\s*$", REm);
+		if((m = reName.match(script)).hasMatch())
+			m_title = m.captured(1);
+		staticRE$(reVer, "@version\\s+(.+)\\s*$", REm);
+		if((m = reVer.match(script)).hasMatch())
+			m_version = m.captured(1);
+		staticRE$(reSummary, "@summary\\s+(.+)\\s*$", REm);
+		if((m = reSummary.match(script)).hasMatch())
+			m_description = m.captured(1);
+		staticRE$(reAuthor, "@author\\s+(.+)\\s*$", REm);
+		if((m = reAuthor.match(script)).hasMatch())
+			m_author = m.captured(1);
+	}
+
+	friend class QVector<SCScript>;
+	SCScript() noexcept {}
+	SCScript(const SCScript &) noexcept = default;
+	SCScript & operator=(const SCScript &) noexcept = default;
+	SCScript(SCScript &&) noexcept = default;
+	SCScript & operator=(SCScript &&) noexcept = default;
+
 public:
-	InstalledScriptsModel(QObject *parent = 0) : QStringListModel(parent) {}
+	QString content() const
+	{
+		QFile jsf(m_path);
+		if(!jsf.open(QFile::ReadOnly | QFile::Text))
+			return QString();
+		return QTextStream(&jsf).readAll();
+	}
+
+	inline bool isScript() const { return m_isScript; }
+
+	inline const QString & name() const { return m_name; }
+	inline const QString & path() const { return m_path; }
+
+	inline const QString & title() const { return m_title; }
+	inline const QString & version() const { return m_version; }
+	inline const QString & category() const { return m_category; }
+	inline const QString & description() const { return m_description; }
+	inline const QString & author() const { return m_author; }
+
+	inline int compare(const SCScript &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
+	{ return m_title.compare(other.m_title, cs); }
 
-	virtual ~InstalledScriptsModel() {}
+private:
+	QString m_name;
+	QString m_path;
 
-	QVariant headerData(int /*section */, Qt::Orientation orientation, int role) const override
+	bool m_isScript;
+	QString m_title;
+	QString m_version;
+	QString m_category;
+	QString m_description;
+	QString m_author;
+};
+
+class InstalledScriptsModel : public QAbstractItemModel
+{
+	Q_OBJECT
+
+	enum { Title, Version, Author, Path, ColumnCount };
+
+public:
+	InstalledScriptsModel(QObject *parent = 0) : QAbstractItemModel(parent) {}
+	~InstalledScriptsModel() {}
+
+	QVariant headerData(int section, Qt::Orientation orientation, int role) const override
 	{
 		if(role != Qt::DisplayRole || orientation == Qt::Vertical)
 			return QVariant();
-		return i18n("Installed Scripts");
+		switch(section) {
+		case Title: return i18n("Title");
+		case Version: return i18n("Version");
+		case Author: return i18n("Author");
+		case Path: return i18n("Path");
+		default: return QString();
+		}
 	}
 
 	Qt::ItemFlags flags(const QModelIndex &index) const override
 	{
-		return QAbstractItemModel::flags(index);
+		if(index.internalId() > 0)
+			return Qt::ItemNeverHasChildren | Qt::ItemIsSelectable | Qt::ItemIsEnabled;
+		return Qt::ItemIsEnabled;
 	}
-};
-}
 
-using namespace SubtitleComposer;
+	int childIndex(const QString &categoryName, int row) const
+	{
+		for(int i = 0, si = 0; i < m_scripts.size(); i++) {
+			const SCScript &s = m_scripts.at(i);
+			if(s.category() != categoryName)
+				continue;
+			if(si == row)
+				return i;
+			si++;
+		}
+		Q_ASSERT(false);
+		return -1;
+	}
+
+	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override
+	{
+		if(!hasIndex(row, column, parent))
+			return QModelIndex();
+
+		if(!parent.isValid()) {
+			// category
+			if(row < m_categories.size())
+				return createIndex(row, column, quintptr(0ULL));
+			// script (root)
+			return createIndex(row, column, childIndex(QString(), row - m_categories.size()) + 1);
+		} else {
+			// script (child)
+			Q_ASSERT(!parent.parent().isValid());
+			Q_ASSERT(parent.row() < m_categories.size());
+			const QString catName = m_categories.at(parent.row());
+			return createIndex(row, column, childIndex(catName, row) + 1);
+		}
+	}
 
-Debug::Debug()
-{}
+	QModelIndex parent(const QModelIndex &child) const override
+	{
+		if(!child.isValid() || child.internalId() == 0)
+			return QModelIndex();
+
+		// script
+		Q_ASSERT(int(child.internalId()) <= m_scripts.size());
+		const SCScript &s = m_scripts.at(child.internalId() - 1);
+		const int i = m_categories.indexOf(s.category());
+		if(i >= 0) // script (child)
+			return createIndex(i, 0, quintptr(0ULL));
+		return QModelIndex(); // script (root)
+	}
 
-Debug::~Debug()
-{}
+	int scriptCount(const QString &categoryName) const
+	{
+		int n = 0;
+		for(int i = 0; i < m_scripts.size(); i++) {
+			if(m_scripts.at(i).category() == categoryName)
+				n++;
+		}
+		return n;
+	}
 
-void
-Debug::information(const QString &message)
-{
-	KMessageBox::information(app()->mainWindow(), message, i18n("Information"));
-	qDebug() << message;
-}
+	int rowCount(const QModelIndex &parent = QModelIndex()) const override
+	{
+		if(!parent.isValid())
+			return m_categories.size() + scriptCount(QString());
+		if(parent.row() >= m_categories.size())
+			return 0;
+		return scriptCount(m_categories.at(parent.row()));
+	}
 
-void
-Debug::warning(const QString &message)
-{
-	KMessageBox::sorry(app()->mainWindow(), message, i18n("Warning"));
-	qWarning() << message;
-}
+	int columnCount(const QModelIndex &parent = QModelIndex()) const override
+	{
+		Q_UNUSED(parent);
+		return ColumnCount;
+	}
 
-void
-Debug::error(const QString &message)
+	QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override
+	{
+		if(index.internalId() > 0) {
+			if(role == Qt::DisplayRole) {
+				switch(index.column()) {
+				case Title: return m_scripts.at(index.internalId() - 1).title();
+				case Version: return m_scripts.at(index.internalId() - 1).version();
+				case Author: return m_scripts.at(index.internalId() - 1).author();
+				case Path: return m_scripts.at(index.internalId() - 1).path();
+				}
+			} else if(role == Qt::ToolTipRole) {
+				if(index.column() == Path)
+					return m_scripts.at(index.internalId() - 1).path();
+				return m_scripts.at(index.internalId() - 1).description();
+			}
+		} else {
+			if(role == Qt::DisplayRole && index.column() == Title) {
+				const QString title = m_categories.at(index.row());
+				return title.isEmpty() ? $("Misc") : title;
+			}
+		}
+		return QVariant();
+
+	}
+
+	const SCScript * findByName(const QString &name) const
+	{
+		if(name.isEmpty())
+			return nullptr;
+		for(auto it = m_scripts.begin(); it != m_scripts.end(); ++it) {
+			if(it->name() == name)
+				return &(*it);
+		}
+		return nullptr;
+	}
+
+	const SCScript * findByTitle(const QString &title) const
+	{
+		if(title.isEmpty())
+			return nullptr;
+		for(auto it = m_scripts.begin(); it != m_scripts.end(); ++it) {
+			if(it->title() == title)
+				return &(*it);
+		}
+		return nullptr;
+	}
+
+	void removeAll()
+	{
+		beginRemoveRows(QModelIndex(), 0, m_categories.size());
+		m_categories.clear();
+		m_scripts.clear();
+		endRemoveRows();
+	}
+
+	inline const SCScript * at(int index) const { return &m_scripts.at(index); }
+
+	template<class T>
+	const T * insertSorted(QVector<T> *vec, T &&el)
+	{
+		for(int i = 0; i < vec->size(); i++) {
+			if(vec->at(i).compare(el, Qt::CaseInsensitive) >= 0) {
+				vec->insert(i, std::move(el));
+				return &vec->at(i);
+			}
+		}
+		vec->push_back(std::move(el));
+		return &vec->last();
+	}
+
+	const SCScript * add(const QString &path, int prefixLen)
+	{
+		const QString name = path.mid(prefixLen);
+		if(findByName(name))
+			return nullptr;
+
+		const SCScript *script = insertSorted(&m_scripts, SCScript(path, name));
+		const QString catTitle = script->category();
+
+		int catIndex = m_categories.indexOf(catTitle);
+		if(catIndex < 0 && !catTitle.isEmpty()) {
+			catIndex = m_categories.size();
+			beginInsertRows(QModelIndex(), catIndex, catIndex + 1);
+			insertSorted(&m_categories, QString(catTitle));
+			endInsertRows();
+		}
+
+		const int n = m_scripts.size();
+		beginInsertRows(catTitle.isEmpty() ? QModelIndex() : createIndex(catIndex, 0, quintptr(0ULL)), n - 1, n + 1);
+		endInsertRows();
+		return script;
+	}
+
+private:
+	QVector<SCScript> m_scripts;
+	QVector<QString> m_categories;
+};
+
+class Debug : public QObject
 {
-	KMessageBox::error(app()->mainWindow(), message, i18n("Error"));
-	qWarning() << message;
+	Q_OBJECT
+
+public:
+	Debug() {}
+	~Debug() {}
+
+public slots:
+	void information(const QString &message)
+	{
+		KMessageBox::information(app()->mainWindow(), message, i18n("Information"));
+		qDebug() << message;
+	}
+
+	void warning(const QString &message)
+	{
+		KMessageBox::sorry(app()->mainWindow(), message, i18n("Warning"));
+		qWarning() << message;
+	}
+
+	void error(const QString &message)
+	{
+		KMessageBox::error(app()->mainWindow(), message, i18n("Error"));
+		qWarning() << message;
+	}
+};
 }
 
+using namespace SubtitleComposer;
+
 ScriptsManager::ScriptsManager(QObject *parent)
 	: QObject(parent)
 {
 	m_dialog = new QDialog(app()->mainWindow());
 	setupUi(m_dialog);
 
+	scriptsView->header()->setSectionResizeMode(QHeaderView::ResizeToContents);
 	scriptsView->installEventFilter(this);
+	scriptsView->selectionModel()->deleteLater();
 	scriptsView->setModel(new InstalledScriptsModel(scriptsView));
-	scriptsView->setRootIsDecorated(false);
 	scriptsView->setSortingEnabled(false);
-
-	connect(btnCreate, &QPushButton::clicked, [this](){ createScript(); });
-	connect(btnAdd, &QPushButton::clicked, [this](){ addScript(); });
-	connect(btnRemove, &QPushButton::clicked, [this](){ removeScript(); });
-	connect(btnEdit, &QPushButton::clicked, [this](){ editScript(); });
-	connect(btnRun, &QPushButton::clicked, [this](){ runScript(); });
-	connect(btnRefresh, &QAbstractButton::clicked, [this](){ reloadScripts(); });
-
-//	m_dialog->resize(350, 10);
+	scriptsView->expandAll();
+	connect(scriptsView, &QTreeView::doubleClicked, this, [&](){ editScript(); });
+	connect(scriptsView->selectionModel(), &QItemSelectionModel::currentRowChanged, this, [&](){
+		const SCScript *s = currentScript();
+		const bool isScriptSelected = s && s->isScript();
+		const bool isFileWritable = s && QFileInfo(s->path()).isWritable();
+		btnRemove->setEnabled(isFileWritable);
+		if(isFileWritable) {
+			btnEdit->setText(i18n("Edit"));
+			btnEdit->setIcon(QIcon::fromTheme($("document-edit")));
+		} else {
+			btnEdit->setText(i18n("View"));
+			btnEdit->setIcon(QIcon::fromTheme($("document-open")));
+		}
+		btnEdit->setEnabled(isScriptSelected);
+		btnRun->setEnabled(isScriptSelected);
+	});
+
+	connect(btnCreate, &QPushButton::clicked, this, [&](){ createScript(); });
+	connect(btnAdd, &QPushButton::clicked, this, [&](){ addScript(); });
+	connect(btnRemove, &QPushButton::clicked, this, [&](){ removeScript(); });
+	connect(btnEdit, &QPushButton::clicked, this, [&](){ editScript(); });
+	connect(btnRun, &QPushButton::clicked, this, [&](){ runScript(); });
+	connect(btnRefresh, &QAbstractButton::clicked, this, [&](){ reloadScripts(); });
 }
 
 ScriptsManager::~ScriptsManager()
@@ -133,17 +425,20 @@ ScriptsManager::showDialog()
 	m_dialog->show();
 }
 
-QString
-ScriptsManager::currentScriptName() const
+const SCScript *
+ScriptsManager::findScript(const QString title) const
 {
-	QModelIndex currentIndex = scriptsView->currentIndex();
-	return currentIndex.isValid() ? scriptsView->model()->data(currentIndex, Qt::DisplayRole).toString() : 0;
+	const SCScript *s = title.isEmpty() ? nullptr : static_cast<InstalledScriptsModel *>(scriptsView->model())->findByTitle(title);
+	return s ?: currentScript();
 }
 
-QStringList
-ScriptsManager::scriptNames() const
+const SCScript *
+ScriptsManager::currentScript() const
 {
-	return m_scripts.keys();
+	const QModelIndex ci = scriptsView->currentIndex();
+	if(ci.isValid() && ci.internalId() > 0)
+		return static_cast<InstalledScriptsModel *>(scriptsView->model())->at(ci.internalId() - 1);
+	return nullptr;
 }
 
 void
@@ -151,12 +446,22 @@ ScriptsManager::createScript(const QString &sN)
 {
 	QString scriptName = sN;
 
-	while(scriptName.isEmpty() || m_scripts.contains(scriptName)) {
-		if(m_scripts.contains(scriptName)
-			&& KMessageBox::questionYesNo(app()->mainWindow(),
-				i18n("You must enter an unused name to continue.\nWould you like to enter another name?"),
-				i18n("Name Already Used"), KStandardGuiItem::cont(), KStandardGuiItem::cancel()) != KMessageBox::Yes)
-			return;
+	InstalledScriptsModel *model = static_cast<InstalledScriptsModel *>(scriptsView->model());
+
+	const SCScript *script = nullptr;
+	while(scriptName.isEmpty() || (script = model->findByTitle(scriptName))) {
+		if(script) {
+			QFileInfo fp(script->path());
+			if(!fp.canonicalFilePath().startsWith(userScriptDir().canonicalPath())) {
+				// a system script can be overridden by user
+				scriptName = script->name();
+				break;
+			}
+			if(KMessageBox::questionYesNo(app()->mainWindow(),
+					i18n("You must enter an unused name to continue.\nWould you like to enter another name?"),
+					i18n("Name Already Used"), KStandardGuiItem::cont(), KStandardGuiItem::cancel()) != KMessageBox::Yes)
+				return;
+		}
 
 		TextInputDialog nameDlg(i18n("Create New Script"), i18n("Script name:"));
 		if(nameDlg.exec() != QDialog::Accepted)
@@ -164,24 +469,19 @@ ScriptsManager::createScript(const QString &sN)
 		scriptName = nameDlg.value();
 	}
 
-	QDir scriptPath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation));
-	if(!scriptPath.exists("scripts"))
-		scriptPath.mkpath("scripts");
-	scriptPath.cd("scripts");
-
-	QFile scriptFile(scriptPath.absoluteFilePath(scriptName));
+	QFile scriptFile(userScriptDir().absoluteFilePath(scriptName));
 	if(!scriptFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
-		KMessageBox::sorry(app()->mainWindow(), i18n("There was an error creating the file <b>%1</b>.", scriptPath.absoluteFilePath(scriptName)));
+		KMessageBox::sorry(app()->mainWindow(), i18n("There was an error creating the file <b>%1</b>.", userScriptDir().absoluteFilePath(scriptName)));
 		return;
 	}
 
 	QTextStream outputStream(&scriptFile);
-	QString scriptExtension = QFileInfo(scriptName).suffix().toLower();
-	if(scriptExtension == QLatin1String("rb"))
-		outputStream << "#!/usr/bin/env ruby";
-	else if(scriptExtension == QLatin1String("py"))
-		outputStream << "#!/usr/bin/env python";
-	outputStream << "\n";
+	outputStream << "/*\n"
+		"\t@name " << scriptName << " Title\n"
+		"\t@version 1.0\n"
+		"\t@summary " << scriptName << " summary/short desription.\n"
+		"\t@author Author's Name\n"
+		"*/\n";
 
 	scriptFile.close();
 
@@ -194,16 +494,8 @@ ScriptsManager::mimeTypes()
 {
 	static QStringList mimeTypes;
 
-	if(mimeTypes.isEmpty()) {
-		QHash<QString, Kross::InterpreterInfo *> infos = Kross::Manager::self().interpreterInfos();
-		for(QHash<QString, Kross::InterpreterInfo *>::ConstIterator it = infos.constBegin(), end = infos.constEnd(); it != end; ++it) {
-			QStringList intMimeTypes = it.value()->mimeTypes();
-			for(QStringList::ConstIterator it = intMimeTypes.constBegin(), end = intMimeTypes.constEnd(); it != end; ++it)
-				mimeTypes << *it;
-		}
-		if(!mimeTypes.contains("application/javascript") && !mimeTypes.contains("text/javascript") && !mimeTypes.contains("application/x-javascript"))
-			mimeTypes.prepend("application/javascript");
-	}
+	if(mimeTypes.isEmpty())
+		mimeTypes.append("application/javascript");
 
 	return mimeTypes;
 }
@@ -223,14 +515,14 @@ ScriptsManager::addScript(const QUrl &sSU)
 		if(fileDialog.exec() != QDialog::Accepted)
 			return;
 
-		srcScriptUrl = fileDialog.selectedUrls().first();
+		srcScriptUrl = fileDialog.selectedUrls().constFirst();
 	}
 
 	QString scriptName = QFileInfo(srcScriptUrl.fileName()).fileName();
 
-	while(m_scripts.contains(scriptName)) {
-		if(m_scripts.contains(scriptName)
-			&& KMessageBox::questionYesNo(app()->mainWindow(),
+	InstalledScriptsModel *model = static_cast<InstalledScriptsModel *>(scriptsView->model());
+	while(model->findByTitle(scriptName)) {
+		if(KMessageBox::questionYesNo(app()->mainWindow(),
 				i18n("You must enter an unused name to continue.\nWould you like to enter another name?"),
 				i18n("Name Already Used"), KStandardGuiItem::cont(), KStandardGuiItem::cancel()) != KMessageBox::Yes)
 			return;
@@ -241,11 +533,6 @@ ScriptsManager::addScript(const QUrl &sSU)
 		scriptName = nameDlg.value();
 	}
 
-	QDir scriptPath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation));
-	if(!scriptPath.exists("scripts"))
-		scriptPath.mkpath("scripts");
-	scriptPath.cd("scripts");
-
 	FileLoadHelper fileLoadHelper(srcScriptUrl);
 
 	if(!fileLoadHelper.open()) {
@@ -253,7 +540,7 @@ ScriptsManager::addScript(const QUrl &sSU)
 		return;
 	}
 
-	QFile dest(scriptPath.absoluteFilePath(scriptName));
+	QFile dest(userScriptDir().absoluteFilePath(scriptName));
 	if(!dest.open(QIODevice::WriteOnly | QIODevice::Truncate)
 			|| dest.write(fileLoadHelper.file()->readAll()) == -1
 			|| !dest.flush()) {
@@ -267,17 +554,16 @@ ScriptsManager::addScript(const QUrl &sSU)
 void
 ScriptsManager::removeScript(const QString &sN)
 {
-	QString scriptName = sN.isEmpty() ? currentScriptName() : sN;
-	if(scriptName.isEmpty() || !m_scripts.contains(scriptName)) {
-		qWarning() << "unknown script specified";
+	const SCScript *script = findScript(sN);
+	if(!script)
 		return;
-	}
 
-	if(KMessageBox::warningContinueCancel(app()->mainWindow(), i18n("Do you really want to send file <b>%1</b> to the trash?", scriptName), i18n("Move to Trash")) != KMessageBox::Continue)
+	if(KMessageBox::warningContinueCancel(app()->mainWindow(),
+			i18n("Do you really want to send file <b>%1</b> to the trash?", script->path()), i18n("Move to Trash")) != KMessageBox::Continue)
 		return;
 
-	if(!FileTrasher(m_scripts[scriptName]).exec()) {
-		KMessageBox::sorry(app()->mainWindow(), i18n("There was an error removing the file <b>%1</b>.", m_scripts[scriptName]));
+	if(!FileTrasher(script->path()).exec()) {
+		KMessageBox::sorry(app()->mainWindow(), i18n("There was an error removing the file <b>%1</b>.", script->path()));
 		return;
 	}
 
@@ -287,25 +573,25 @@ ScriptsManager::removeScript(const QString &sN)
 void
 ScriptsManager::editScript(const QString &sN)
 {
-	QString scriptName = sN.isEmpty() ? currentScriptName() : sN;
-	if(scriptName.isEmpty() || !m_scripts.contains(scriptName)) {
+	const SCScript *script = findScript(sN);
+	if(!script) {
 		qWarning() << "unknown script specified";
 		return;
 	}
 
-	const QUrl script = QUrl::fromLocalFile(m_scripts[scriptName]);
+	const QUrl scriptUrl = QUrl::fromLocalFile(script->path());
 #ifdef SC_APPIMAGE
 	{
 #elif KIO_VERSION >= QT_VERSION_CHECK(5, 71, 0)
-	KIO::OpenUrlJob *job = new KIO::OpenUrlJob(script);
+	KIO::OpenUrlJob *job = new KIO::OpenUrlJob(scriptUrl);
 	job->setUiDelegate(new KIO::JobUiDelegate(KJobUiDelegate::AutoHandlingEnabled, app()->mainWindow()));
 	if(!job->exec()) {
 #elif KIO_VERSION >= QT_VERSION_CHECK(5, 31, 0)
-	if(!KRun::runUrl(script, "text/plain", app()->mainWindow(), KRun::RunFlags())) {
+	if(!KRun::runUrl(scriptUrl, "text/plain", app()->mainWindow(), KRun::RunFlags())) {
 #else
-	if(!KRun::runUrl(script, "text/plain", app()->mainWindow(), false, false)) {
+	if(!KRun::runUrl(scriptUrl, "text/plain", app()->mainWindow(), false, false)) {
 #endif
-		if(!QDesktopServices::openUrl(script))
+		if(!QDesktopServices::openUrl(scriptUrl))
 			KMessageBox::sorry(app()->mainWindow(), i18n("Could not launch external editor.\n"));
 	}
 }
@@ -313,63 +599,39 @@ ScriptsManager::editScript(const QString &sN)
 void
 ScriptsManager::runScript(const QString &sN)
 {
-	if(!app()->subtitle()) {
-		qWarning() << "attempt to run script without a working subtitle";
+	const SCScript *script = findScript(sN);
+	if(!script || !script->isScript())
 		return;
-	}
-
-	QString scriptName = sN;
-
-	if(scriptName.isEmpty()) {
-		scriptName = currentScriptName();
-		if(scriptName.isEmpty())
-			return;
-	}
 
-	if(!m_scripts.contains(scriptName)) {
-		qWarning() << "unknown script file specified";
+	QJSEngine jse;
+	jse.installExtensions(QJSEngine::ConsoleExtension);
+	jse.globalObject().setProperty("ranges", jse.newQObject(new Scripting::RangesModule));
+	jse.globalObject().setProperty("strings", jse.newQObject(new Scripting::StringsModule));
+	jse.globalObject().setProperty("subtitle", jse.newQObject(new Scripting::SubtitleModule));
+	jse.globalObject().setProperty("subtitleline", jse.newQObject(new Scripting::SubtitleLineModule));
+	jse.globalObject().setProperty("debug", jse.newQObject(new Debug()));
+
+	QString scriptData = script->content();
+	if(scriptData.isNull()) {
+		KMessageBox::error(app()->mainWindow(), i18n("Error opening script %1.", script->path()), i18n("Error Running Script"));
 		return;
 	}
 
-	Kross::Action krossAction(0, "Kross::Action");
-
-	Scripting::RangesModule *rangesModule = new Scripting::RangesModule;
-	Scripting::StringsModule *stringsModule = new Scripting::StringsModule;
-	Scripting::SubtitleModule *subtitleModule = new Scripting::SubtitleModule;
-	Scripting::SubtitleLineModule *subtitleLineModule = new Scripting::SubtitleLineModule;
-	Debug *debug = new Debug();
-
-	krossAction.addObject(rangesModule, "ranges");
-	krossAction.addObject(stringsModule, "strings");
-	krossAction.addObject(subtitleModule, "subtitle");
-	krossAction.addObject(subtitleLineModule, "subtitleline");
-	krossAction.addObject(debug, "debug");
-
-	krossAction.setFile(m_scripts[scriptName]);
-	if(krossAction.interpreter().isEmpty() && scriptName.right(3) == QLatin1String(".js"))
-		krossAction.setInterpreter("qtscript");
-	// default javascript interpreter has weird (crash inducing) bugs
-	else if(krossAction.interpreter() == QLatin1String("javascript"))
-		krossAction.setInterpreter("qtscript");
-
+	QJSValue res;
 	{
 		// everything done by the script will be undoable in a single step
-		SubtitleCompositeActionExecutor executor(app()->subtitle(), scriptName);
-		// execute the script file
-		krossAction.trigger();
+		SubtitleCompositeActionExecutor executor(app()->subtitle(), script->path());
+		res = jse.evaluate(scriptData, script->name());
 	}
 
-	delete rangesModule;
-	delete stringsModule;
-	delete subtitleModule;
-	delete subtitleLineModule;
-	delete debug;
-
-	if(krossAction.hadError()) {
-		if(krossAction.errorTrace().isNull())
-			KMessageBox::error(app()->mainWindow(), krossAction.errorMessage(), i18n("Error Running Script"));
-		else
-			KMessageBox::detailedError(app()->mainWindow(), krossAction.errorMessage(), krossAction.errorTrace(), i18n("Error Running Script"));
+	if(!res.isUndefined()) {
+		if(res.isError()) {
+			const QString details = i18n("Path: %1", script->path()) % "\n"
+				% res.property($("stack")).toString();
+			KMessageBox::detailedError(app()->mainWindow(), res.toString(), details, i18n("Error Running Script"));
+		} else {
+			KMessageBox::error(app()->mainWindow(), res.toString(), i18n("Error Running Script"));
+		}
 	}
 }
 
@@ -390,12 +652,12 @@ ScriptsManager::toolsMenu()
 	return toolsMenu;
 }
 
-/*static*/ void
+void
 ScriptsManager::findAllFiles(QString directory, QStringList &fileList)
 {
 	QDir path(directory);
-	QFileInfoList files = path.entryInfoList();
-	foreach(QFileInfo file, files) {
+	const QFileInfoList files = path.entryInfoList();
+	for(const QFileInfo &file: files) {
 		if(file.isDir()) {
 			if(file.fileName().at(0) != '.')
 				findAllFiles(file.absoluteFilePath(), fileList);
@@ -412,60 +674,58 @@ ScriptsManager::reloadScripts()
 	KActionCollection *actionCollection = app()->mainWindow()->actionCollection();
 	UserActionManager *actionManager = UserActionManager::instance();
 
-	QString selectedPath = scriptsView->model()->rowCount() && !currentScriptName().isEmpty() ? m_scripts[currentScriptName()] : QString();
+	InstalledScriptsModel *model = static_cast<InstalledScriptsModel *>(scriptsView->model());
 
-	m_scripts.clear();
 	toolsMenu->clear();
 	toolsMenu->addAction(app()->action(ACT_SCRIPTS_MANAGER));
 	toolsMenu->addSeparator();
 
-	qDebug() << "KROSS interpreters:" << Kross::Manager::self().interpreters();
-	QStringList scriptExtensions;
-	foreach(const QString interpreter, Kross::Manager::self().interpreters()) {
-		if(interpreter == QStringLiteral("qtscript"))
-			scriptExtensions.append(QStringLiteral(".js"));
-		else if(interpreter == QStringLiteral("ruby"))
-			scriptExtensions.append(QStringLiteral(".rb"));
-		else if(interpreter == QStringLiteral("python"))
-			scriptExtensions.append(QStringLiteral(".py"));
-	}
+	QMap<QString, QMenu *> categoryMenus;
+
+	model->removeAll();
+
+	// make sure userScriptDir is first on the list so it will override system scripts
+	const QString userDir = userScriptDir().absolutePath();
+	QStringList scriptDirs = QStandardPaths::locateAll(QStandardPaths::AppDataLocation, userScriptDir().dirName(), QStandardPaths::LocateDirectory);
+	int pos = scriptDirs.indexOf(userDir);
+	if(pos == -1)
+		scriptDirs.prepend(userDir);
+	else if(pos > 0)
+		scriptDirs.move(pos, 0);
 
-	QStringList scriptDirs = QStandardPaths::locateAll(QStandardPaths::AppDataLocation, "scripts", QStandardPaths::LocateDirectory);
-	QStringList scriptNames;
-	int index = 0, newCurrentIndex = -1;
 	foreach(const QString &path, scriptDirs) {
-		int pathLen = QDir(path).absolutePath().length() + 1;
+		const int pathLen = QDir(path).absolutePath().length() + 1;
 		QStringList scriptPaths;
 		findAllFiles(path, scriptPaths);
 		foreach(const QString &path, scriptPaths) {
-			QString name = path.mid(pathLen);
-			if(m_scripts.contains(name))
+			const SCScript *script = model->add(path, pathLen);
+			if(!script)
 				continue;
 
-			scriptNames << name;
-
-			m_scripts[name] = path;
-
-			QString suffix = name.right(3);
-			if(scriptExtensions.contains(suffix)) {
-				QAction *scriptAction = toolsMenu->addAction(name);
-				scriptAction->setObjectName(name);
-				actionCollection->addAction(name, scriptAction);
+			if(script->isScript()) {
+				QMenu *parentMenu = toolsMenu;
+				if(!script->category().isEmpty()) {
+					auto it = categoryMenus.constFind(script->category());
+					if(it != categoryMenus.cend()) {
+						parentMenu = it.value();
+					} else {
+						parentMenu = new QMenu(script->category(), toolsMenu);
+						categoryMenus[script->category()] = parentMenu;
+					}
+				}
+
+				QAction *scriptAction = parentMenu->addAction(script->title());
+				scriptAction->setObjectName(script->name());
+				if(!script->description().isEmpty())
+					scriptAction->setStatusTip(script->description());
+				actionCollection->addAction(script->name(), scriptAction);
 				actionManager->addAction(scriptAction, UserAction::SubOpened | UserAction::FullScreenOff);
 			}
-
-			if(newCurrentIndex < 0 && path == selectedPath)
-				newCurrentIndex = index;
-			index++;
 		}
 	}
-	scriptNames.sort();
 
-	static_cast<InstalledScriptsModel *>(scriptsView->model())->setStringList(scriptNames);
-	if(!scriptNames.isEmpty()) {
-		QModelIndex currentIndex = scriptsView->model()->index(newCurrentIndex < 0 ? 0 : newCurrentIndex, 0);
-		scriptsView->setCurrentIndex(currentIndex);
-	}
+	for(auto it = categoryMenus.cbegin(); it != categoryMenus.cend(); ++it)
+		toolsMenu->addMenu(it.value());
 }
 
 void
@@ -488,4 +748,4 @@ ScriptsManager::eventFilter(QObject *object, QEvent *event)
 	return QObject::eventFilter(object, event);
 }
 
-
+#include "scriptsmanager.moc"
diff --git a/src/scripting/scriptsmanager.h b/src/scripting/scriptsmanager.h
index d02a4ee..0791905 100644
--- a/src/scripting/scriptsmanager.h
+++ b/src/scripting/scriptsmanager.h
@@ -21,6 +21,7 @@ QT_FORWARD_DECLARE_CLASS(QPushButton)
 class TreeView;
 
 namespace SubtitleComposer {
+class SCScript;
 class Subtitle;
 
 class ScriptsManager : public QObject, private Ui::ScriptsManager
@@ -31,9 +32,6 @@ public:
 	explicit ScriptsManager(QObject *parent = 0);
 	virtual ~ScriptsManager();
 
-	QString currentScriptName() const;
-	QStringList scriptNames() const;
-
 	bool eventFilter(QObject *object, QEvent *event) override;
 
 public slots:
@@ -51,6 +49,8 @@ public slots:
 private:
 	static const QStringList & mimeTypes();
 	QMenu * toolsMenu();
+	const SCScript * currentScript() const;
+	const SCScript * findScript(const QString title) const;
 
 	static void findAllFiles(QString path, QStringList &findAllFiles);
 
@@ -58,22 +58,7 @@ private slots:
 	void onToolsMenuActionTriggered(QAction *action);
 
 private:
-	QMap<QString, QString> m_scripts;               // name => path
 	QDialog *m_dialog;
 };
-
-class Debug : public QObject
-{
-	Q_OBJECT
-
-public:
-	Debug();
-	~Debug();
-
-public slots:
-	void information(const QString &message);
-	void warning(const QString &message);
-	void error(const QString &message);
-};
 }
 #endif
diff --git a/src/scripting/scriptsmanager.ui b/src/scripting/scriptsmanager.ui
index be73654..55dce7f 100644
--- a/src/scripting/scriptsmanager.ui
+++ b/src/scripting/scriptsmanager.ui
@@ -6,8 +6,8 @@
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>400</width>
-    <height>300</height>
+    <width>800</width>
+    <height>500</height>
    </rect>
   </property>
   <property name="windowTitle">
@@ -17,7 +17,7 @@
    <item>
     <layout class="QVBoxLayout" name="mainContent">
      <item>
-      <widget class="TreeView" name="scriptsView"/>
+      <widget class="QTreeView" name="scriptsView"/>
      </item>
     </layout>
    </item>
@@ -33,8 +33,7 @@
        </property>
        <property name="icon">
         <iconset theme="document-new">
-         <normaloff/>
-        </iconset>
+         <normaloff>.</normaloff>.</iconset>
        </property>
       </widget>
      </item>
@@ -48,8 +47,7 @@
        </property>
        <property name="icon">
         <iconset theme="document-open">
-         <normaloff/>
-        </iconset>
+         <normaloff>.</normaloff>.</iconset>
        </property>
       </widget>
      </item>
@@ -63,8 +61,7 @@
        </property>
        <property name="icon">
         <iconset theme="user-trash">
-         <normaloff/>
-        </iconset>
+         <normaloff>.</normaloff>.</iconset>
        </property>
       </widget>
      </item>
@@ -78,8 +75,7 @@
        </property>
        <property name="icon">
         <iconset theme="document-edit">
-         <normaloff/>
-        </iconset>
+         <normaloff>.</normaloff>.</iconset>
        </property>
       </widget>
      </item>
@@ -109,8 +105,7 @@
        </property>
        <property name="icon">
         <iconset theme="media-playback-start">
-         <normaloff/>
-        </iconset>
+         <normaloff>.</normaloff>.</iconset>
        </property>
       </widget>
      </item>
@@ -140,8 +135,7 @@
        </property>
        <property name="icon">
         <iconset theme="view-refresh">
-         <normaloff/>
-        </iconset>
+         <normaloff>.</normaloff>.</iconset>
        </property>
       </widget>
      </item>
@@ -162,13 +156,6 @@
    </item>
   </layout>
  </widget>
- <customwidgets>
-  <customwidget>
-   <class>TreeView</class>
-   <extends>QTreeView</extends>
-   <header>gui/treeview/treeview.h</header>
-  </customwidget>
- </customwidgets>
  <resources/>
  <connections/>
 </ui>
diff --git a/src/speechprocessor/speechprocessor.cpp b/src/speechprocessor/speechprocessor.cpp
index dce8bf5..283346b 100644
--- a/src/speechprocessor/speechprocessor.cpp
+++ b/src/speechprocessor/speechprocessor.cpp
@@ -104,7 +104,7 @@ SpeechProcessor::setAudioStream(const QString &mediaFile, int audioStream)
 	}
 
 	connect(m_plugin, &SpeechPlugin::textRecognized, this, &SpeechProcessor::onTextRecognized);
-	connect(m_plugin, &SpeechPlugin::error, [this](int code, const QString &message) { onStreamError(code, message, QString()); });
+	connect(m_plugin, &SpeechPlugin::error, this, [this](int code, const QString &message) { onStreamError(code, message, QString()); });
 
 	m_mediaFile = mediaFile;
 	m_streamIndex = audioStream;
diff --git a/src/tests/CMakeLists.txt b/src/tests/CMakeLists.txt
index 51abcd9..16cac8a 100644
--- a/src/tests/CMakeLists.txt
+++ b/src/tests/CMakeLists.txt
@@ -5,31 +5,31 @@ include_directories(
 )
 
 add_executable(test-core-rangelist rangelisttest.cpp)
-add_test(subtitlecomposer test-core-rangelist)
+add_test(core-rangelist test-core-rangelist)
 ecm_mark_as_test(test-core-rangelist)
 target_link_libraries(test-core-rangelist Qt5::Test subtitlecomposer-lib)
 
 add_executable(test-core-range rangetest.cpp)
-add_test(subtitlecomposer test-core-range)
+add_test(core-range test-core-range)
 ecm_mark_as_test(test-core-range)
 target_link_libraries(test-core-range Qt5::Test subtitlecomposer-lib)
 
 add_executable(test-core-time timetest.cpp)
-add_test(subtitlecomposer test-core-time)
+add_test(core-time test-core-time)
 ecm_mark_as_test(test-core-time)
 target_link_libraries(test-core-time Qt5::Test subtitlecomposer-lib)
 
 add_executable(test-core-sstring sstringtest.cpp)
-add_test(subtitlecomposer test-core-sstring)
+add_test(core-sstring test-core-sstring)
 ecm_mark_as_test(test-core-sstring)
 target_link_libraries(test-core-sstring Qt5::Test subtitlecomposer-lib)
 
 add_executable(test-core-richdocument richdocumenttest.cpp)
-add_test(subtitlecomposer test-core-richdocument)
+add_test(core-richdocument test-core-richdocument)
 ecm_mark_as_test(test-core-richdocument)
 target_link_libraries(test-core-richdocument Qt5::Test subtitlecomposer-lib)
 
-add_executable(test-subtitle subtitletest.cpp)
-add_test(subtitlecomposer test-subtitle)
-ecm_mark_as_test(test-subtitle)
-target_link_libraries(test-subtitle Qt5::Test subtitlecomposer-lib)
+add_executable(test-core-subtitle subtitletest.cpp)
+add_test(core-subtitle test-core-subtitle)
+ecm_mark_as_test(test-core-subtitle)
+target_link_libraries(test-core-subtitle Qt5::Test subtitlecomposer-lib)
diff --git a/src/tests/subtitletest.cpp b/src/tests/subtitletest.cpp
index 3fdd441..7612567 100644
--- a/src/tests/subtitletest.cpp
+++ b/src/tests/subtitletest.cpp
@@ -33,17 +33,17 @@ SubtitleTest::testSort()
 {
 	QFETCH(QVector<int>, lines);
 
-	sub.removeLines(RangeList(Range::full()), SubtitleTarget::Both);
+	sub->removeLines(RangeList(Range::full()), SubtitleTarget::Both);
 
 	for(int n: lines) {
 		SubtitleLine *l = new SubtitleLine(n * 1000, n * 1000 + 500);
 		l->primaryDoc()->setPlainText(QString::number(n));
-		sub.insertLine(l);
+		sub->insertLine(l);
 	}
 
-	QVERIFY(sub.count() == lines.size());
-	for(int i = 0; i < sub.count(); i++)
-		QVERIFY(qRound(sub.at(i)->showTime().toSeconds()) == i + 1);
+	QVERIFY(sub->count() == lines.size());
+	for(int i = 0; i < sub->count(); i++)
+		QVERIFY(qRound(sub->at(i)->showTime().toSeconds()) == i + 1);
 }
 
 #define QCoreApplication Application
diff --git a/src/tests/subtitletest.h b/src/tests/subtitletest.h
index b8aec1e..8efd59e 100644
--- a/src/tests/subtitletest.h
+++ b/src/tests/subtitletest.h
@@ -15,11 +15,15 @@ class SubtitleTest : public QObject
 {
 	Q_OBJECT
 
-	SubtitleComposer::Subtitle sub;
+public:
+	SubtitleTest() : sub(new SubtitleComposer::Subtitle) {}
 
 private slots:
 	void testSort_data();
 	void testSort();
+
+private:
+	QExplicitlySharedDataPointer<SubtitleComposer::Subtitle> sub;
 };
 
 #endif // SUBTITLESORTTEST_H
diff --git a/src/videoplayer/backend/glrenderer.cpp b/src/videoplayer/backend/glrenderer.cpp
index 7c9c38b..5c0086f 100644
--- a/src/videoplayer/backend/glrenderer.cpp
+++ b/src/videoplayer/backend/glrenderer.cpp
@@ -17,9 +17,11 @@
 
 extern "C" {
 #include "libavutil/pixdesc.h"
+#include "libswscale/swscale.h"
 }
 
 #define DEBUG_GL 0
+#define FORCE_GLES 0
 #define OPENGL_CORE 0
 #define OPENGL_VER 2,0
 
@@ -33,6 +35,21 @@ extern "C" {
 #define asGL(glCall) glCall
 #endif
 
+#if defined(GL_ES_VERSION_2_0) || FORCE_GLES
+#define USE_GLES
+#define TEXTURE_RGB_FORMAT GL_RGBA
+// NOTE: we don't support rendering >8bpp on GLES, so 16bit textures are never used
+//       and cpu will convert the frame to 8bpp
+#define TEXTURE_U16_FORMAT 0x822A
+#else
+#undef USE_GLES
+#define TEXTURE_RGB_FORMAT GL_BGRA
+#define TEXTURE_U16_FORMAT GL_R16
+#endif
+
+#define FRAME_IS_YUV(f) ((f & AV_PIX_FMT_FLAG_RGB) == 0)
+#define FRAME_IS_PLANAR(f) ((f & AV_PIX_FMT_FLAG_PLANAR) != 0)
+
 using namespace SubtitleComposer;
 
 enum { ID_Y, ID_U, ID_V, ID_OVR, ID_SIZE };
@@ -42,6 +59,7 @@ GLRenderer::GLRenderer(QWidget *parent)
 	: QOpenGLWidget(parent),
 	  m_overlay(nullptr),
 	  m_mmOvr(nullptr),
+	  m_frameConvCtx(nullptr),
 	  m_bufYUV(nullptr),
 	  m_mmYUV(nullptr),
 	  m_bufSize(0),
@@ -54,6 +72,7 @@ GLRenderer::GLRenderer(QWidget *parent)
 	  m_fragShader(nullptr),
 	  m_shaderProg(nullptr),
 	  m_texNeedInit(true),
+	  m_lastFormat(-1),
 	  m_idTex(nullptr),
 	  m_vaBuf(nullptr)
 {
@@ -73,6 +92,7 @@ GLRenderer::~GLRenderer()
 	}
 	m_vao.destroy();
 	doneCurrent();
+	sws_freeContext(m_frameConvCtx);
 	delete[] m_bufYUV;
 	delete[] m_mmYUV;
 	delete[] m_mmOvr;
@@ -82,6 +102,9 @@ void
 GLRenderer::setupProfile()
 {
 	QSurfaceFormat format(QSurfaceFormat::defaultFormat());
+#if FORCE_GLES
+	format.setRenderableType(QSurfaceFormat::OpenGLES);
+#endif
 	format.setVersion(OPENGL_VER);
 #if DEBUG_GL
 	format.setOption(QSurfaceFormat::DebugContext);
@@ -98,6 +121,9 @@ GLRenderer::setOverlay(SubtitleTextOverlay *overlay)
 	if(m_overlay)
 		disconnect(m_overlay, nullptr, this, nullptr);
 	m_overlay = overlay;
+#ifdef USE_GLES
+	overlay->invertPixels(true);
+#endif
 	connect(m_overlay, &SubtitleTextOverlay::repaintNeeded, this, QOverload<>::of(&GLRenderer::update));
 }
 
@@ -126,7 +152,7 @@ GLRenderer::setFrameFormat(int width, int height, int compBits, int crWidthShift
 	m_crHeight = crHeight;
 
 	m_glType = compBytes == 1 ? GL_UNSIGNED_BYTE : GL_UNSIGNED_SHORT;
-	m_glFormat = compBytes == 1 ? GL_R8 : GL_R16;
+	m_glFormat = compBytes == 1 ? GL_R8 : TEXTURE_U16_FORMAT;
 
 	delete[] m_bufYUV;
 	m_bufSize = bufSize;
@@ -161,7 +187,7 @@ GLRenderer::setColorspace(const AVFrame *frame)
 	const AVPixFmtDescriptor *fd = av_pix_fmt_desc_get(AVPixelFormat(frame->format));
 	const quint8 compBits = fd->comp[0].depth;
 	const quint8 compBytes = compBits > 8 ? 2 : 1;
-	const bool isYUV = ~fd->flags & AV_PIX_FMT_FLAG_RGB;
+	const bool isYUV = FRAME_IS_YUV(fd->flags);
 
 	qDebug("Color range: %s(%d); primaries: %s(%d); xfer: %s(%d); space: %s(%d); depth: %d",
 		   av_color_range_name(frame->color_range), frame->color_range,
@@ -210,6 +236,123 @@ GLRenderer::setColorspace(const AVFrame *frame)
 	m_csCM.scale(pixMult, pixMult, pixMult);
 }
 
+bool
+GLRenderer::validTextureFormat(const AVPixFmtDescriptor *fd)
+{
+	const uint64_t &f = fd->flags;
+	if((f & AV_PIX_FMT_FLAG_BITSTREAM)) {
+		qCritical("uploadTexture() failed: unsupported frame format [%s] - bitstream", fd->name);
+		return false;
+	}
+	if((f & AV_PIX_FMT_FLAG_PAL)) {
+		qCritical("uploadTexture() failed: unsupported frame format [%s] - palette", fd->name);
+		return false;
+	}
+	if((f & AV_PIX_FMT_FLAG_BE)) {
+		qCritical("uploadTexture() failed: unsupported frame format [%s] - bigendian", fd->name);
+		return false;
+	}
+
+	if(FRAME_IS_YUV(f) && FRAME_IS_PLANAR(f)) {
+		const quint8 b = fd->comp[0].depth > 8 ? 2 : 1;
+		if(fd->comp[0].step != b || fd->comp[1].step != b || fd->comp[2].step != b) {
+			qCritical("validTextureFormat() failed: unsupported plane step [%d, %d, %d] %s",
+				   fd->comp[0].step, fd->comp[1].step, fd->comp[2].step, fd->name);
+			return false;
+		}
+		if(fd->comp[0].offset || fd->comp[1].offset || fd->comp[2].offset) {
+			qCritical("validTextureFormat() failed: unsupported plane offset [%d, %d, %d] %s",
+				   fd->comp[0].offset, fd->comp[1].offset, fd->comp[2].offset, fd->name);
+			return false;
+		}
+		if(fd->comp[0].shift || fd->comp[1].shift || fd->comp[2].shift) {
+			qCritical("validTextureFormat() failed: unsupported plane shift [%d, %d, %d] %s",
+				   fd->comp[0].shift, fd->comp[1].shift, fd->comp[2].shift, fd->name);
+			return false;
+		}
+		if(fd->comp[0].depth != fd->comp[1].depth || fd->comp[0].depth != fd->comp[2].depth) {
+			qCritical("validTextureFormat() failed: unsupported plane depths [%d, %d, %d] %s",
+				   fd->comp[0].depth, fd->comp[1].depth, fd->comp[2].depth, fd->name);
+			return false;
+		}
+		if(fd->nb_components < 3) {
+			qCritical("validTextureFormat() failed: unsupported plane count [%d] %s",
+					  fd->nb_components, fd->name);
+			return false;
+		}
+	} else {
+		qCritical("validTextureFormat() failed: unsupported frame format [%s]", fd->name);
+		return false;
+	}
+	return true;
+}
+
+int
+GLRenderer::uploadTexture(AVFrame *frame)
+{
+	const AVPixFmtDescriptor *fd = av_pix_fmt_desc_get(AVPixelFormat(frame->format));
+	if(m_lastFormat != frame->format) {
+		if(!validTextureFormat(fd))
+			return -1;
+		m_lastFormat = frame->format;
+	}
+
+	if(!frame->linesize[0] || !frame->linesize[1] || !frame->linesize[2]) {
+		qCritical("uploadTexture() failed: invalid linesize [%d, %d, %d]",
+			   frame->linesize[0], frame->linesize[1], frame->linesize[2]);
+		return -1;
+	}
+
+	QMutexLocker l(&m_texMutex);
+
+#ifdef USE_GLES
+	if(fd->comp[0].depth > 8) {
+		// convert >8bpp YUV
+		frame->format = AV_PIX_FMT_YUV420P;
+
+		const static AVPixFmtDescriptor *fd8 = av_pix_fmt_desc_get(AVPixelFormat(frame->format));
+		m_frameConvCtx = sws_getCachedContext(m_frameConvCtx,
+				frame->width, frame->height, AVPixelFormat(m_lastFormat),
+				frame->width, frame->height, AVPixelFormat(frame->format),
+				0, nullptr, nullptr, nullptr);
+
+		setFrameFormat(frame->width, frame->height,
+			fd8->comp[0].depth, fd8->log2_chroma_w, fd8->log2_chroma_h);
+
+		setColorspace(frame);
+
+		sws_scale(m_frameConvCtx, frame->data, frame->linesize, 0, frame->height,
+				m_pixels, reinterpret_cast<const int *>(m_pitch));
+	} else
+#endif
+	{
+		setFrameFormat(frame->width, frame->height,
+			fd->comp[0].depth, fd->log2_chroma_w, fd->log2_chroma_h);
+
+		setColorspace(frame);
+
+		if(frame->linesize[0] > 0)
+			setFrameY(frame->data[0], frame->linesize[0]);
+		else
+			setFrameY(frame->data[0] + frame->linesize[0] * (frame->height - 1), -frame->linesize[0]);
+
+		if(frame->linesize[1] > 0)
+			setFrameU(frame->data[1], frame->linesize[1]);
+		else
+			setFrameU(frame->data[1] + frame->linesize[1] * (AV_CEIL_RSHIFT(frame->height, 1) - 1), -frame->linesize[1]);
+
+		if(frame->linesize[2] > 0)
+			setFrameV(frame->data[2], frame->linesize[2]);
+		else
+			setFrameV(frame->data[2] + frame->linesize[2] * (AV_CEIL_RSHIFT(frame->height, 1) - 1), -frame->linesize[2]);
+	}
+
+	m_texUploaded = false;
+	update();
+
+	return 0;
+}
+
 void
 GLRenderer::setFrameY(quint8 *buf, quint32 pitch)
 {
@@ -261,7 +404,11 @@ GLRenderer::initShader()
 	delete m_vertShader;
 	m_vertShader = new QOpenGLShader(QOpenGLShader::Vertex, this);
 	bool success = m_vertShader->compileSourceCode(
+#ifdef USE_GLES
+		"#version 100\n"
+#else
 		"#version 120\n"
+#endif
 		"attribute vec4 vPos;"
 		"attribute vec2 vVidTex;"
 		"attribute vec2 vOvrTex;"
@@ -288,7 +435,13 @@ GLRenderer::initShader()
 		csms.append(QString::number(csm[i], 'g', 10));
 	}
 
-	success = m_fragShader->compileSourceCode(QStringLiteral("#version 120\n"
+	success = m_fragShader->compileSourceCode(QStringLiteral(
+#ifdef USE_GLES
+		"#version 100\n"
+		"precision mediump float;\n"
+#else
+		"#version 120\n"
+#endif
 		"varying vec2 vfVidTex;"
 		"varying vec2 vfOvrTex;"
 		"uniform sampler2D texY;"
@@ -348,8 +501,15 @@ GLRenderer::initializeGL()
 	QMutexLocker l(&m_texMutex);
 
 	initializeOpenGLFunctions();
-	qDebug() << "OpenGL version: " << reinterpret_cast<const char *>(glGetString(GL_VERSION));
-	qDebug() << "GLSL version: " << reinterpret_cast<const char *>(glGetString(GL_SHADING_LANGUAGE_VERSION));
+	qDebug().nospace() << "GL API: OpenGL " << (format().renderableType() == QSurfaceFormat::OpenGLES ? "ES" : "Desktop")
+		<< ' ' << format().majorVersion() << "." << format().minorVersion()
+#ifdef USE_GLES
+		<< " (compiled for OpenGL ES)";
+#else
+		<< " (compiled for OpenGL Desktop)";
+#endif
+	qDebug() << "OpenGL version:" << reinterpret_cast<const char *>(glGetString(GL_VERSION));
+	qDebug() << "GLSL version:" << reinterpret_cast<const char *>(glGetString(GL_SHADING_LANGUAGE_VERSION));
 
 	if(m_vao.create())
 		m_vao.bind();
@@ -453,13 +613,13 @@ GLRenderer::uploadMM(int texWidth, int texHeight, T *texBuf, const T *texSrc)
 			if(D == 1) {
 				asGL(glTexImage2D(GL_TEXTURE_2D, level, m_glFormat, texWidth, texHeight, 0, GL_RED, m_glType, texSrc));
 			} else { // D == 4
-				asGL(glTexImage2D(GL_TEXTURE_2D, level, GL_RGBA8, texWidth, texHeight, 0, GL_BGRA, GL_UNSIGNED_BYTE, texSrc));
+				asGL(glTexImage2D(GL_TEXTURE_2D, level, GL_RGBA8, texWidth, texHeight, 0, TEXTURE_RGB_FORMAT, GL_UNSIGNED_BYTE, texSrc));
 			}
 		} else {
 			if(D == 1) {
 				asGL(glTexSubImage2D(GL_TEXTURE_2D, level, 0, 0, texWidth, texHeight, GL_RED, m_glType, texSrc));
 			} else { // D == 4
-				asGL(glTexSubImage2D(GL_TEXTURE_2D, level, 0, 0, texWidth, texHeight, GL_BGRA, GL_UNSIGNED_BYTE, texSrc));
+				asGL(glTexSubImage2D(GL_TEXTURE_2D, level, 0, 0, texWidth, texHeight, TEXTURE_RGB_FORMAT, GL_UNSIGNED_BYTE, texSrc));
 			}
 		}
 
@@ -506,6 +666,11 @@ GLRenderer::uploadMM(int texWidth, int texHeight, T *texBuf, const T *texSrc)
 void
 GLRenderer::uploadYUV()
 {
+	if(!m_texNeedInit && m_texUploaded)
+		return;
+
+	m_texUploaded = true;
+
 	// load Y data
 	asGL(glActiveTexture(GL_TEXTURE0 + ID_Y));
 	asGL(glBindTexture(GL_TEXTURE_2D, m_idTex[ID_Y]));
@@ -575,7 +740,7 @@ GLRenderer::uploadSubtitle()
 	// overlay
 	asGL(glActiveTexture(GL_TEXTURE0 + ID_OVR));
 	asGL(glBindTexture(GL_TEXTURE_2D, m_idTex[ID_OVR]));
-	uploadMM<quint8, 4>(img.width(), img.height(), m_mmOvr, img.bits());
+	uploadMM<quint8, 4>(img.width(), img.height(), m_mmOvr, img.constBits());
 	if(m_texNeedInit) {
 		asGL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER));
 		asGL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER));
diff --git a/src/videoplayer/backend/glrenderer.h b/src/videoplayer/backend/glrenderer.h
index bb90396..b517786 100644
--- a/src/videoplayer/backend/glrenderer.h
+++ b/src/videoplayer/backend/glrenderer.h
@@ -21,6 +21,9 @@ extern "C" {
 QT_FORWARD_DECLARE_CLASS(QOpenGLShader)
 QT_FORWARD_DECLARE_CLASS(QOpenGLShaderProgram)
 
+struct AVPixFmtDescriptor;
+struct SwsContext;
+
 namespace SubtitleComposer {
 class SubtitleTextOverlay;
 
@@ -40,6 +43,7 @@ public:
 
 	void setFrameFormat(int width, int height, int compBits, int crWidthShift, int crHeightShift);
 	void setColorspace(const AVFrame *frame);
+	int uploadTexture(AVFrame *frame);
 	void setFrameY(quint8 *buf, quint32 pitch);
 	void setFrameU(quint8 *buf, quint32 pitch);
 	void setFrameV(quint8 *buf, quint32 pitch);
@@ -60,6 +64,7 @@ private:
 	template<class T, int D> void uploadMM(int texWidth, int texHeight, T *texBuf, const T *texSrc);
 	void uploadYUV();
 	void uploadSubtitle();
+	bool validTextureFormat(const AVPixFmtDescriptor *fd);
 
 private:
 	SubtitleTextOverlay *m_overlay;
@@ -68,6 +73,7 @@ private:
 
 	QOpenGLVertexArrayObject m_vao;
 
+	SwsContext *m_frameConvCtx;
 	quint8 *m_bufYUV, *m_mmYUV;
 	quint32 m_bufSize;
 	GLsizei m_bufWidth, m_bufHeight;
@@ -85,6 +91,8 @@ private:
 	QOpenGLShaderProgram *m_shaderProg;
 
 	bool m_texNeedInit;
+	bool m_texUploaded;
+	int m_lastFormat;
 	int m_vpWidth, m_vpHeight;
 	int m_texY, m_texU, m_texV, m_texOvr;
 	GLuint *m_idTex;
diff --git a/src/videoplayer/backend/renderthread.cpp b/src/videoplayer/backend/renderthread.cpp
index 051832d..695e74b 100644
--- a/src/videoplayer/backend/renderthread.cpp
+++ b/src/videoplayer/backend/renderthread.cpp
@@ -23,8 +23,7 @@ using namespace SubtitleComposer;
 
 RenderThread::RenderThread(VideoState *state, QObject *parent)
 	: QThread(parent),
-	  m_vs(state),
-	  m_lastFormat(-1)
+	  m_vs(state)
 {
 }
 
@@ -35,6 +34,8 @@ RenderThread::run()
 	for(;;) {
 		if(remaining_time > 0.0)
 			av_usleep((int64_t)(remaining_time * double(AV_TIME_BASE)));
+		else
+			yieldCurrentThread(); // allow gui to update
 		remaining_time = REFRESH_RATE;
 		if(isInterruptionRequested())
 			break;
@@ -412,8 +413,10 @@ RenderThread::videoImageDisplay()
 #endif
 
 	if(!vp->uploaded) {
-		if(uploadTexture(vp->frame) < 0)
+		if(m_vs->glRenderer->uploadTexture(vp->frame) < 0) {
+			requestInterruption();
 			return;
+		}
 		vp->uploaded = true;
 	}
 
@@ -473,103 +476,3 @@ RenderThread::toggleAudioDisplay()
 		m_vs->showMode = ShowMode(next);
 	}
 }
-
-bool
-RenderThread::validTextureFormat(const AVPixFmtDescriptor *fd)
-{
-	const uint64_t &f = fd->flags;
-	if((f & AV_PIX_FMT_FLAG_BITSTREAM)) {
-		qCritical("uploadTexture() failed: unsupported frame format [%s] - bitstream", fd->name);
-		return false;
-	}
-	if((f & AV_PIX_FMT_FLAG_PAL)) {
-		qCritical("uploadTexture() failed: unsupported frame format [%s] - palette", fd->name);
-		return false;
-	}
-	if((f & AV_PIX_FMT_FLAG_BE)) {
-		qCritical("uploadTexture() failed: unsupported frame format [%s] - bigendian", fd->name);
-		return false;
-	}
-
-	m_isYUV = !(f & AV_PIX_FMT_FLAG_RGB);
-	m_isPlanar = f & AV_PIX_FMT_FLAG_PLANAR;
-	if(m_isPlanar && m_isYUV) {
-		const quint8 b = fd->comp[0].depth > 8 ? 2 : 1;
-		if(fd->comp[0].step != b || fd->comp[1].step != b || fd->comp[2].step != b) {
-			qCritical("validTextureFormat() failed: unsupported plane step [%d, %d, %d] %s",
-				   fd->comp[0].step, fd->comp[1].step, fd->comp[2].step, fd->name);
-			return false;
-		}
-		if(fd->comp[0].offset || fd->comp[1].offset || fd->comp[2].offset) {
-			qCritical("validTextureFormat() failed: unsupported plane offset [%d, %d, %d] %s",
-				   fd->comp[0].offset, fd->comp[1].offset, fd->comp[2].offset, fd->name);
-			return false;
-		}
-		if(fd->comp[0].shift || fd->comp[1].shift || fd->comp[2].shift) {
-			qCritical("validTextureFormat() failed: unsupported plane shift [%d, %d, %d] %s",
-				   fd->comp[0].shift, fd->comp[1].shift, fd->comp[2].shift, fd->name);
-			return false;
-		}
-		if(fd->comp[0].depth != fd->comp[1].depth || fd->comp[0].depth != fd->comp[2].depth) {
-			qCritical("validTextureFormat() failed: unsupported plane depths [%d, %d, %d] %s",
-				   fd->comp[0].depth, fd->comp[1].depth, fd->comp[2].depth, fd->name);
-			return false;
-		}
-		if(fd->nb_components < 3) {
-			qCritical("validTextureFormat() failed: unsupported plane count [%d] %s",
-					  fd->nb_components, fd->name);
-			return false;
-		}
-	} else {
-		qCritical("validTextureFormat() failed: unsupported frame format [%s]", fd->name);
-		return false;
-	}
-	return true;
-}
-
-int
-RenderThread::uploadTexture(AVFrame *frame)
-{
-	const AVPixFmtDescriptor *fd = av_pix_fmt_desc_get(AVPixelFormat(frame->format));
-	if(m_lastFormat != frame->format) {
-		if(!validTextureFormat(fd)) {
-			requestInterruption();
-			return -1;
-		}
-		m_lastFormat = frame->format;
-	}
-
-	if(m_isPlanar && m_isYUV) {
-		if(!frame->linesize[0] || !frame->linesize[1] || !frame->linesize[2]) {
-			qCritical("uploadTexture() failed: invalid linesize [%d, %d, %d]",
-				   frame->linesize[0], frame->linesize[1], frame->linesize[2]);
-			return -1;
-		}
-
-		QMutexLocker l(m_vs->glRenderer->mutex());
-
-		m_vs->glRenderer->setFrameFormat(frame->width, frame->height,
-			fd->comp[0].depth, fd->log2_chroma_w, fd->log2_chroma_h);
-
-		m_vs->glRenderer->setColorspace(frame);
-
-		if(frame->linesize[0] > 0)
-			m_vs->glRenderer->setFrameY(frame->data[0], frame->linesize[0]);
-		else
-			m_vs->glRenderer->setFrameY(frame->data[0] + frame->linesize[0] * (frame->height - 1), -frame->linesize[0]);
-
-		if(frame->linesize[1] > 0)
-			m_vs->glRenderer->setFrameU(frame->data[1], frame->linesize[1]);
-		else
-			m_vs->glRenderer->setFrameU(frame->data[1] + frame->linesize[1] * (AV_CEIL_RSHIFT(frame->height, 1) - 1), -frame->linesize[1]);
-
-		if(frame->linesize[2] > 0)
-			m_vs->glRenderer->setFrameV(frame->data[2], frame->linesize[2]);
-		else
-			m_vs->glRenderer->setFrameV(frame->data[2] + frame->linesize[2] * (AV_CEIL_RSHIFT(frame->height, 1) - 1), -frame->linesize[2]);
-
-		m_vs->glRenderer->update();
-	}
-
-	return 0;
-}
diff --git a/src/videoplayer/backend/renderthread.h b/src/videoplayer/backend/renderthread.h
index a2d0677..8a563f4 100644
--- a/src/videoplayer/backend/renderthread.h
+++ b/src/videoplayer/backend/renderthread.h
@@ -37,14 +37,11 @@ private:
 	double computeTargetDelay(double delay);
 	void updateSampleDisplay(short *samples, int samplesSize);
 	void toggleAudioDisplay();
-	bool validTextureFormat(const AVPixFmtDescriptor *fd);
-	int uploadTexture(AVFrame *frame);
 	void videoImageDisplay();
 	void videoAudioDisplay();
 
 private:
 	VideoState *m_vs;
-	int m_lastFormat;
 	bool m_isYUV;
 	bool m_isPlanar;
 };
diff --git a/src/videoplayer/backend/videostate.h b/src/videoplayer/backend/videostate.h
index a669f0f..160b6f7 100644
--- a/src/videoplayer/backend/videostate.h
+++ b/src/videoplayer/backend/videostate.h
@@ -24,6 +24,7 @@
 extern "C" {
 #include "libavformat/avformat.h"
 #include "libavcodec/avfft.h"
+#include "libswscale/swscale.h"
 }
 
 
diff --git a/src/videoplayer/subtitletextoverlay.cpp b/src/videoplayer/subtitletextoverlay.cpp
index afcb344..9fedd5b 100644
--- a/src/videoplayer/subtitletextoverlay.cpp
+++ b/src/videoplayer/subtitletextoverlay.cpp
@@ -18,7 +18,8 @@
 using namespace SubtitleComposer;
 
 SubtitleTextOverlay::SubtitleTextOverlay()
-	: m_fontSize(SCConfig::fontSize())
+	: m_invertPixels(false),
+	  m_fontSize(SCConfig::fontSize())
 {
 	m_font.setStyleStrategy(QFont::PreferAntialias);
 }
@@ -192,6 +193,16 @@ SubtitleTextOverlay::image()
 	return m_image;
 }
 
+void
+SubtitleTextOverlay::invertPixels(bool invert)
+{
+	if(m_invertPixels == invert)
+		return;
+	m_invertPixels = invert;
+	setTextColor(m_textColor);
+	setOutlineColor(m_textOutline.color());
+}
+
 const QSize &
 SubtitleTextOverlay::textSize()
 {
@@ -278,8 +289,10 @@ SubtitleTextOverlay::setFontSize(int fontSize)
 }
 
 void
-SubtitleTextOverlay::setTextColor(const QColor &color)
+SubtitleTextOverlay::setTextColor(QColor color)
 {
+	if(m_invertPixels)
+		color = QColor(color.blue(), color.green(), color.red(), color.alpha());
 	if(m_textColor == color)
 		return;
 	m_textColor = color;
@@ -287,8 +300,10 @@ SubtitleTextOverlay::setTextColor(const QColor &color)
 }
 
 void
-SubtitleTextOverlay::setOutlineColor(const QColor &color)
+SubtitleTextOverlay::setOutlineColor(QColor color)
 {
+	if(m_invertPixels)
+		color = QColor(color.blue(), color.green(), color.red(), color.alpha());
 	if(m_textOutline.color() == color)
 		return;
 	m_textOutline.setColor(color);
diff --git a/src/videoplayer/subtitletextoverlay.h b/src/videoplayer/subtitletextoverlay.h
index 5cbe508..204c1fb 100644
--- a/src/videoplayer/subtitletextoverlay.h
+++ b/src/videoplayer/subtitletextoverlay.h
@@ -36,6 +36,7 @@ public:
 	const QSize & textSize();
 	inline bool isDirty() const { return m_dirty; }
 	inline double renderScale() const { return m_renderScale; }
+	void invertPixels(bool invert);
 
 private:
 	void drawImage();
@@ -53,12 +54,13 @@ public slots:
 	void setDoc(const RichDocument *doc);
 	void setFontFamily(const QString &family);
 	void setFontSize(int fontSize);
-	void setTextColor(const QColor &color);
-	void setOutlineColor(const QColor &color);
+	void setTextColor(QColor color);
+	void setOutlineColor(QColor color);
 	void setOutlineWidth(int width);
 	inline void setRenderScale(double scale) { m_renderScale = scale; }
 
 private:
+	bool m_invertPixels;
 	QString m_text;
 	const RichDocument *m_doc = nullptr;
 	QFont m_font;
